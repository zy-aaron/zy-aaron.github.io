<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zy-aaron.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="keepalived版本：2.0.20 前言在分析源码时，本文去除了一些冗余的代码和相关的调试宏，仅突出主要的代码逻辑。 主函数分析：keepalived_main为keepalived的主函数，负责：  部分全局变量的初始化 配置文件的解析和读取 健康检查子进程的创建  下面是keepalived_main中的主要代码： 123456789101112&#x2F;* 创建并初始化全局变量thread_ma">
<meta property="og:type" content="article">
<meta property="og:title" content="keepalived源码分析">
<meta property="og:url" content="https://zy-aaron.github.io/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="赵耀的博客">
<meta property="og:description" content="keepalived版本：2.0.20 前言在分析源码时，本文去除了一些冗余的代码和相关的调试宏，仅突出主要的代码逻辑。 主函数分析：keepalived_main为keepalived的主函数，负责：  部分全局变量的初始化 配置文件的解析和读取 健康检查子进程的创建  下面是keepalived_main中的主要代码： 123456789101112&#x2F;* 创建并初始化全局变量thread_ma">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-01T06:29:35.000Z">
<meta property="article:modified_time" content="2024-09-01T06:31:53.497Z">
<meta property="article:author" content="Aaron Zhao">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zy-aaron.github.io/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zy-aaron.github.io/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","path":"2023/12/01/keepalived源码分析/","title":"keepalived源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>keepalived源码分析 | 赵耀的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">赵耀的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">主函数分析：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-master-t"><span class="nav-number">3.1.</span> <span class="nav-text">thread_master_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-t"><span class="nav-number">3.2.</span> <span class="nav-text">thread_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#checker-t"><span class="nav-number">3.3.</span> <span class="nav-text">checker_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual-server-t"><span class="nav-number">3.4.</span> <span class="nav-text">virtual_server_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#real-server-t"><span class="nav-number">3.5.</span> <span class="nav-text">real_server_t</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">健康检查子进程调用逻辑分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#start-check-child"><span class="nav-number">4.1.</span> <span class="nav-text">start_check_child</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start-check"><span class="nav-number">4.2.</span> <span class="nav-text">start_check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-checkers-thread"><span class="nav-number">4.3.</span> <span class="nav-text">register_checkers_thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#launch-thread-scheduler"><span class="nav-number">4.4.</span> <span class="nav-text">launch_thread_scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-fetch-next-queue"><span class="nav-number">4.5.</span> <span class="nav-text">thread_fetch_next_queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9A%E6%97%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">事件的触发机制和定时机制分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-timerfd-handler"><span class="nav-number">5.1.</span> <span class="nav-text">thread_timerfd_handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-set-timer"><span class="nav-number">5.2.</span> <span class="nav-text">thread_set_timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-add-timer"><span class="nav-number">5.3.</span> <span class="nav-text">thread_add_timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-add-read"><span class="nav-number">5.4.</span> <span class="nav-text">thread_add_read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-add-write"><span class="nav-number">5.5.</span> <span class="nav-text">thread_add_write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8Elvs%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">与lvs的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ipvs-init"><span class="nav-number">6.1.</span> <span class="nav-text">ipvs_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init-services"><span class="nav-number">6.2.</span> <span class="nav-text">init_services</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-svr-checker-state"><span class="nav-number">6.3.</span> <span class="nav-text">update_svr_checker_state</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aaron Zhao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1946697015@qq.com" title="E-Mail → mailto:1946697015@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="keepalived源码分析 | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          keepalived源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-01 14:29:35" itemprop="dateCreated datePublished" datetime="2023-12-01T14:29:35+08:00">2023-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 14:31:53" itemprop="dateModified" datetime="2024-09-01T14:31:53+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/keepalived/" itemprop="url" rel="index"><span itemprop="name">keepalived</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>keepalived版本：2.0.20</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在分析源码时，本文去除了一些冗余的代码和相关的调试宏，仅突出主要的代码逻辑。</p>
<h2 id="主函数分析："><a href="#主函数分析：" class="headerlink" title="主函数分析："></a>主函数分析：</h2><p>keepalived_main为keepalived的主函数，负责：</p>
<ol>
<li>部分全局变量的初始化</li>
<li>配置文件的解析和读取</li>
<li>健康检查子进程的创建</li>
</ol>
<p>下面是keepalived_main中的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建并初始化全局变量thread_master_t *master */</span></span><br><span class="line">master = thread_make_master();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号处理函数初始化 */</span></span><br><span class="line">signal_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start_keepalived开启健康检查子进程，主进程会返回 */</span></span><br><span class="line"><span class="keyword">if</span> (!start_keepalived())</span><br><span class="line">	log_message(LOG_INFO, <span class="string">&quot;Warning - keepalived has no configuration to run&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主进程开启epoll，主要负责监控子进程，一般情况下不会返回 */</span></span><br><span class="line">launch_thread_scheduler(master);</span><br></pre></td></tr></table></figure>

<h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="thread-master-t"><a href="#thread-master-t" class="headerlink" title="thread_master_t"></a>thread_master_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量master的结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_master</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 带缓存的红黑树 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	read;  <span class="comment">/* 读线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	write; <span class="comment">/* 写线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	timer; <span class="comment">/* 计时线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	child; <span class="comment">/* 子线程 */</span></span><br><span class="line">	<span class="type">list_head_t</span>		event;     <span class="comment">/* 事件列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGNAL_THREADS</span></span><br><span class="line">	<span class="type">list_head_t</span> 		signal;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">list_head_t</span>		ready; <span class="comment">/* 就绪事件 */</span></span><br><span class="line">	<span class="type">list_head_t</span>		unuse; <span class="comment">/* 未使用事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相关子进程 */</span></span><br><span class="line">	<span class="type">rb_root_t</span>		child_pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* epoll 相关 */</span></span><br><span class="line">	<span class="type">rb_root_t</span>		io_events;         <span class="comment">/* events集合，每次创建event都会添加到io_events内 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>	*<span class="title">epoll_events</span>;</span></span><br><span class="line">	<span class="type">thread_event_t</span>		*current_event;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		epoll_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		epoll_count;</span><br><span class="line">	<span class="type">int</span>			epoll_fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计时相关 */</span></span><br><span class="line">	<span class="type">int</span>			timer_fd;</span><br><span class="line">	<span class="type">thread_t</span>		*timer_thread;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 信号相关 */</span></span><br><span class="line">	<span class="type">int</span>			signal_fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WITH_SNMP_</span></span><br><span class="line">	<span class="comment">/* snmp related */</span></span><br><span class="line">	<span class="type">thread_t</span>		*snmp_timer_thread;</span><br><span class="line">	<span class="type">int</span>			snmp_fdsetsize;</span><br><span class="line">	fd_set			snmp_fdset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 本地数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		alloc;  <span class="comment">/* 已分配线程计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		id;</span><br><span class="line">	<span class="type">bool</span>			shutdown_timer_running;</span><br><span class="line">&#125; <span class="type">thread_master_t</span>;</span><br></pre></td></tr></table></figure>

<p>下面是master的初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_master_t</span> *</span><br><span class="line"><span class="title function_">thread_make_master</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_master_t</span> *new;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* malloc动态分配内存 */</span></span><br><span class="line">	new = (<span class="type">thread_master_t</span> *) MALLOC(<span class="keyword">sizeof</span> (<span class="type">thread_master_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个epoll fd */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_EPOLL_CREATE1</span></span><br><span class="line">	new-&gt;epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	new-&gt;epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (new-&gt;epoll_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: Error creating EPOLL instance (%m)&quot;</span>);</span><br><span class="line">		FREE(new);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化其他变量 */</span></span><br><span class="line">	new-&gt;read = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;write = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;timer = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;child = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;io_events = RB_ROOT;</span><br><span class="line">	new-&gt;child_pid = RB_ROOT;</span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;event);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGNAL_THREADS</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;signal);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;ready);</span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;unuse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建timerfd */</span></span><br><span class="line">	new-&gt;timer_fd = timerfd_create(CLOCK_MONOTONIC,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TFD_NONBLOCK				<span class="comment">/* Since Linux 2.6.27 */</span></span></span><br><span class="line">						        TFD_NONBLOCK | TFD_CLOEXEC</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">							<span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">										  );</span><br><span class="line">	<span class="keyword">if</span> (new-&gt;timer_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_ERR, <span class="string">&quot;scheduler: Cant create timerfd (%m)&quot;</span>);</span><br><span class="line">		FREE(new);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过signalfd初始化信号fd */</span></span><br><span class="line">	new-&gt;signal_fd = signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个计时线程（thread_t），添加到new-&gt;read内，后续便可以被epoll监听，</span></span><br><span class="line"><span class="comment">	* 并将new-&gt;timer_thread赋值为该线程</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	new-&gt;timer_thread = thread_add_read(new, thread_timerfd_handler, <span class="literal">NULL</span>, new-&gt;timer_fd, TIMER_NEVER, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化signal_thread(thread_t)全局变量，并将其添加到new-&gt;read内 */</span></span><br><span class="line">	add_signal_read_thread(new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-t"><a href="#thread-t" class="headerlink" title="thread_t"></a>thread_t</h3><p>下面是普通线程thread_t的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="type">thread_type_t</span> type;		<span class="comment">/* 线程类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_master</span> *<span class="title">master</span>;</span>	<span class="comment">/* 指向主线程的指针 */</span></span><br><span class="line">	<span class="type">int</span> (*func)(<span class="keyword">struct</span> _thread *);	<span class="comment">/* 发生对应事件时的回调函数 */</span></span><br><span class="line">	<span class="type">void</span> *arg;			<span class="comment">/* 回调函数参数 */</span></span><br><span class="line">	<span class="type">timeval_t</span> sands;		<span class="comment">/* 剩余时间沙的值 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		<span class="type">int</span> fd;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">pid_t</span> pid;</span><br><span class="line">			<span class="type">int</span> status;</span><br><span class="line">		&#125; c;</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_event</span> *<span class="title">event</span>;</span> <span class="comment">/* 对应事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rb_node_t</span> n;</span><br><span class="line">		<span class="type">list_head_t</span> next;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">rb_node_t</span> rb_data;</span><br><span class="line">&#125; <span class="type">thread_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="checker-t"><a href="#checker-t" class="headerlink" title="checker_t"></a>checker_t</h3><p>每种健康检查对应一个checker，下面是checker_t的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">checker</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>				(*free_func) (<span class="type">void</span> *);			<span class="comment">/* free回调 */</span></span><br><span class="line">	<span class="type">void</span>				(*dump_func) (FILE *, <span class="type">void</span> *);	<span class="comment">/* dump回调 */</span></span><br><span class="line">	<span class="type">int</span>				(*launch) (<span class="keyword">struct</span> _thread *);		<span class="comment">/* 启动健康检查时的回调 */</span></span><br><span class="line">	<span class="type">bool</span>				(*compare) (<span class="type">void</span> *, <span class="type">void</span> *);	<span class="comment">/* 比较函数，用于红黑树排序 */</span></span><br><span class="line">	<span class="type">virtual_server_t</span>		*vs;			<span class="comment">/* checker线程的虚服务 */</span></span><br><span class="line">	<span class="type">real_server_t</span>			*rs;			<span class="comment">/* checker线程的实服务 */</span></span><br><span class="line">	<span class="type">void</span>				*data;</span><br><span class="line">	<span class="type">bool</span>				enabled;		<span class="comment">/* 是否开启当前健康检查 */</span></span><br><span class="line">	<span class="type">bool</span>				is_up;			<span class="comment">/* 当前健康检查是否在运行 */</span></span><br><span class="line">	<span class="type">bool</span>				has_run;		<span class="comment">/* 当前健康检查已经至少运行过一次 */</span></span><br><span class="line">	<span class="type">conn_opts_t</span>			*co;			<span class="comment">/* 连接相关参数 */</span></span><br><span class="line">	<span class="type">int</span>				alpha;			<span class="comment">/* alpha模式 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;		<span class="comment">/* 健康检查每次运行的时间间隔 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;			<span class="comment">/* 启动健康检查时的最大随机超时时间 */</span></span><br><span class="line">	<span class="type">unsigned</span>			retry;			<span class="comment">/* 健康检查失败后重试次数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;	<span class="comment">/* 健康检查失败后重试之间的间隔 */</span></span><br><span class="line">	<span class="type">unsigned</span>			retry_it;		<span class="comment">/* 连续失败次数 */</span></span><br><span class="line">	<span class="type">unsigned</span>			default_retry;		<span class="comment">/* 健康检查失败后重试次数（默认） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			default_delay_before_retry; <span class="comment">/* 健康检查失败后重试之间的间隔（默认） */</span></span><br><span class="line">&#125; <span class="type">checker_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="virtual-server-t"><a href="#virtual-server-t" class="headerlink" title="virtual_server_t"></a>virtual_server_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">virtual_server</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*vsgname;	 	<span class="comment">/* 虚服务组名 */</span></span><br><span class="line">	<span class="type">virtual_server_group_t</span>		*vsg;	<span class="comment">/* 虚服务组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>		<span class="title">addr</span>;</span>	<span class="comment">/* 虚服务地址 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			vfwmark;</span><br><span class="line">	<span class="type">real_server_t</span>			*s_svr;		<span class="comment">/* sorry server */</span></span><br><span class="line">	<span class="type">bool</span>				s_svr_duplicates_rs;</span><br><span class="line">	<span class="type">uint16_t</span>			af;</span><br><span class="line">	<span class="type">uint16_t</span>			service_type;	<span class="comment">/* 虚服务类型，如IPPROTO_TCP、IPPROTO_UDP */</span></span><br><span class="line">	<span class="type">bool</span>				ha_suspend;</span><br><span class="line">	<span class="type">int</span>				ha_suspend_addr_count;</span><br><span class="line">	<span class="type">char</span>				sched[IP_VS_SCHEDNAME_MAXLEN];</span><br><span class="line">	<span class="type">uint32_t</span>			flags;</span><br><span class="line">	<span class="type">uint32_t</span>			persistence_timeout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下方配置基本为配置文件内的可选项 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			persistence_granularity;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*virtualhost;</span><br><span class="line">	<span class="type">int</span>				weight;</span><br><span class="line">	<span class="built_in">list</span>				rs;</span><br><span class="line">	<span class="type">int</span>				alive;</span><br><span class="line">	<span class="type">bool</span>				alpha;</span><br><span class="line">	<span class="type">bool</span>				omega;</span><br><span class="line">	<span class="type">bool</span>				inhibit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			connection_to;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;</span><br><span class="line">	<span class="type">unsigned</span>			retry;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_quorum_up;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_quorum_down;</span><br><span class="line">	<span class="type">unsigned</span>			quorum;</span><br><span class="line">	<span class="type">unsigned</span>			hysteresis;</span><br><span class="line">	<span class="type">int</span>				smtp_alert;</span><br><span class="line">	<span class="type">bool</span>				quorum_state_up;</span><br><span class="line">	<span class="type">bool</span>				reloaded;</span><br><span class="line">&#125; <span class="type">virtual_server_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="real-server-t"><a href="#real-server-t" class="headerlink" title="real_server_t"></a>real_server_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">real_server</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>		<span class="title">addr</span>;</span></span><br><span class="line">	<span class="type">int</span>				weight;</span><br><span class="line">	<span class="type">int</span>				iweight;	<span class="comment">/* 初始权重 */</span></span><br><span class="line">	<span class="type">int</span>				pweight;	<span class="comment">/* reloading前的权重 */</span></span><br><span class="line">	<span class="type">unsigned</span>			forwarding_method; <span class="comment">/* NAT/TUN/DR */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下方配置基本为配置文件内的可选项 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			u_threshold;</span><br><span class="line">	<span class="type">uint32_t</span>			l_threshold;</span><br><span class="line">	<span class="type">int</span>				inhibit;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_up;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_down;</span><br><span class="line">	<span class="type">int</span>				alpha;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			connection_to;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;</span><br><span class="line">	<span class="type">unsigned</span>			retry;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;</span><br><span class="line">	<span class="type">int</span>				smtp_alert;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>				alive;				<span class="comment">/* 实服务器是否存活 */</span></span><br><span class="line">	<span class="type">unsigned</span>			num_failed_checkers;<span class="comment">/* 失败的健康检查计数 */</span></span><br><span class="line">	<span class="type">bool</span>				<span class="built_in">set</span>;		<span class="comment">/* 是否在ipvs内被设置 */</span></span><br><span class="line">	<span class="type">bool</span>				reloaded;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*virtualhost;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">real_server_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="健康检查子进程调用逻辑分析"><a href="#健康检查子进程调用逻辑分析" class="headerlink" title="健康检查子进程调用逻辑分析"></a>健康检查子进程调用逻辑分析</h2><h3 id="start-check-child"><a href="#start-check-child" class="headerlink" title="start_check_child"></a>start_check_child</h3><p>下面为创建子进程的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">start_check_child</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> *syslog_ident;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;Healthcheck child process: fork error(%s)&quot;</span></span><br><span class="line">			       , strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid) &#123;</span><br><span class="line">        <span class="comment">/* 父进程部分 */</span></span><br><span class="line">		checkers_child = pid;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;Starting Healthcheck child process, pid=%d&quot;</span></span><br><span class="line">			       , pid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建子线程，添加到master-&gt;child */</span></span><br><span class="line">		thread_add_child(master, check_respawn_thread, <span class="literal">NULL</span>,</span><br><span class="line">				 pid, TIMER_NEVER);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* 子进程部分 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设定当父进程死亡时，子进程收到SIGTERM信号 */</span></span><br><span class="line">	prctl(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设定当前进程类型为PROG_TYPE_CHECKER，与之相对的父进程类型为PROG_TYPE_PARENT */</span></span><br><span class="line">	prog_type = PROG_TYPE_CHECKER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 销毁父进程创建的master */</span></span><br><span class="line">	thread_destroy_master(master);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程的master */</span></span><br><span class="line">	master = thread_make_master();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DEBUG_</span></span><br><span class="line">	<span class="comment">/* 检查子进程的信号处理函数 */</span></span><br><span class="line">	check_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 开启健康检查 */</span></span><br><span class="line">	start_check(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 启动epoll，用于监测健康检查事件，死循环，一般不会返回 */</span></span><br><span class="line">	launch_thread_scheduler(master);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 结束健康检查 */</span></span><br><span class="line">	<span class="keyword">if</span> (two_phase_terminate)</span><br><span class="line">		checker_terminate_phase2();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		stop_check(KEEPALIVED_EXIT_OK);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(KEEPALIVED_EXIT_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="start-check"><a href="#start-check" class="headerlink" title="start_check"></a>start_check</h3><p>下面是开启健康检查的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_check</span><span class="params">(<span class="built_in">list</span> old_checkers_queue, <span class="type">data_t</span> *old_global_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化全局变量checkers_queue */</span></span><br><span class="line">	init_checkers_queue();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解析配置文件内关键字，同时将配置文件内的健康检查注册进checkers_queue内 */</span></span><br><span class="line">	init_data(conf_file, check_init_keywords);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化ipvs，加载ipvs模块 */</span></span><br><span class="line">	<span class="keyword">if</span> ((!LIST_ISEMPTY(check_data-&gt;vs) || (reload &amp;&amp; !LIST_ISEMPTY(old_check_data-&gt;vs))) &amp;&amp;</span><br><span class="line">	    ipvs_start() != IPVS_SUCCESS) &#123;</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ssl上下文初始化 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_data-&gt;ssl_required &amp;&amp; !init_ssl_ctx())</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置timer_now全局变量 */</span></span><br><span class="line">	set_time_now();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化ipvs虚服务和实服务 */</span></span><br><span class="line">	<span class="keyword">if</span> (!init_services())</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册健康检查线程 */</span></span><br><span class="line">	register_checkers_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="register-checkers-thread"><a href="#register-checkers-thread" class="headerlink" title="register_checkers_thread"></a>register_checkers_thread</h3><p>下面是注册健康检查线程的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">register_checkers_thread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">checker_t</span> *checker;</span><br><span class="line">	element e;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> warmup;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历checkers_queue */</span></span><br><span class="line">	LIST_FOREACH(checkers_queue, checker, e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;launch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (checker-&gt;vs-&gt;ha_suspend &amp;&amp; !checker-&gt;vs-&gt;ha_suspend_addr_count)</span><br><span class="line">				checker-&gt;enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 设置一段随机超时时间，避免同时对同一实服务器开启健康检查 */</span></span><br><span class="line">			warmup = checker-&gt;warmup;</span><br><span class="line">			<span class="keyword">if</span> (warmup)</span><br><span class="line">				warmup = warmup * (<span class="type">unsigned</span>)rand() / RAND_MAX;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前健康检查添加到master线程的timer红黑树中 */</span></span><br><span class="line">			thread_add_timer(master, checker-&gt;launch, checker,</span><br><span class="line">					 BOOTSTRAP_DELAY + warmup);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="launch-thread-scheduler"><a href="#launch-thread-scheduler" class="headerlink" title="launch_thread_scheduler"></a>launch_thread_scheduler</h3><p>使用epoll开启线程调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">launch_thread_scheduler</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal_set(SIGCHLD, thread_child_handler, m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 处理事件调度 */</span></span><br><span class="line">	process_threads(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启事件调度 */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_threads</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_t</span>* thread;</span><br><span class="line">	<span class="type">list_head_t</span> *thread_list;</span><br><span class="line">	<span class="type">int</span> thread_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * thread_fetch_next_queue会阻塞直到ready列表内有就绪的事件，</span></span><br><span class="line"><span class="comment">	 * 其内部通过epoll_wait读取master线程内的read和write就绪的事件，并将其放到ready列表内，之后返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> ((thread_list = thread_fetch_next_queue(m))) &#123;</span><br><span class="line">		thread = thread_trim_head(thread_list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 对于符合条件的线程，调用其func回调 */</span></span><br><span class="line">		<span class="keyword">if</span> (!shutting_down ||</span><br><span class="line">		    (thread-&gt;type == THREAD_READY_FD &amp;&amp;</span><br><span class="line">		     (thread-&gt;u.fd == m-&gt;timer_fd || thread-&gt;u.fd == m-&gt;signal_fd)) ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD_TIMEOUT ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD_TERMINATED ||</span><br><span class="line">		    thread-&gt;type == THREAD_TIMER_SHUTDOWN ||</span><br><span class="line">		    thread-&gt;type == THREAD_TERMINATE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (thread-&gt;func)</span><br><span class="line">				thread_call(thread);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (thread-&gt;type == THREAD_TERMINATE_START)</span><br><span class="line">				shutting_down = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 记录下当前事件，这会加速事件的初始化速度 */</span></span><br><span class="line">		m-&gt;current_event = (thread-&gt;type == THREAD_READY_READ_FD || thread-&gt;type == THREAD_READY_WRITE_FD) ? thread-&gt;event : <span class="literal">NULL</span>;</span><br><span class="line">		thread_type = thread-&gt;type;</span><br><span class="line">		thread_add_unuse(master, thread);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 关闭 */</span></span><br><span class="line">		<span class="keyword">if</span> (shutting_down &amp;&amp; !m-&gt;shutdown_timer_running &amp;&amp; !m-&gt;child.rb_root.rb_node)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 终止 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_type == THREAD_TERMINATE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-fetch-next-queue"><a href="#thread-fetch-next-queue" class="headerlink" title="thread_fetch_next_queue"></a>thread_fetch_next_queue</h3><p>我们的所有健康检查任务和定时事件都会在这里被监听</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得下一个准备好的事件（线程） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">list_head_t</span> *</span><br><span class="line"><span class="title function_">thread_fetch_next_queue</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> last_epoll_errno = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* event列表中有就绪事件，返回event列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;event.next != &amp;m-&gt;event)</span><br><span class="line">		<span class="keyword">return</span> &amp;m-&gt;event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ready列表中有就绪时间，返回ready列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;ready.next != &amp;m-&gt;ready)</span><br><span class="line">		<span class="keyword">return</span> &amp;m-&gt;ready;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 从read、write、timer、child四个红黑树中找到最近的超时时间，</span></span><br><span class="line"><span class="comment">		通过timerfd_settime()开启定时任务计时 */</span></span><br><span class="line">		thread_set_timer(m);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 调用epoll函数（阻塞） */</span></span><br><span class="line">		ret = epoll_wait(m-&gt;epoll_fd, m-&gt;epoll_events, m-&gt;epoll_count, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* epoll_wait调用出错 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (check_EINTR(errno))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (errno != last_epoll_errno) &#123;</span><br><span class="line">				last_epoll_errno = errno;</span><br><span class="line"></span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;scheduler: epoll_wait error: %s&quot;</span>, strerror(errno));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (last_epoll_errno == EBADF || last_epoll_errno == EFAULT || last_epoll_errno == EINVAL)</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 处理epoll事件 */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_ev</span>;</span></span><br><span class="line">			<span class="type">thread_event_t</span> *ev;</span><br><span class="line"></span><br><span class="line">			ep_ev = &amp;m-&gt;epoll_events[i];</span><br><span class="line">			ev = ep_ev-&gt;data.ptr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 对应事件出错 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; (EPOLLHUP | EPOLLERR | EPOLLRDHUP)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ev-&gt;read) &#123;</span><br><span class="line">					thread_move_ready(m, &amp;m-&gt;read, ev-&gt;read, THREAD_READ_ERROR);</span><br><span class="line">					ev-&gt;read = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ev-&gt;write) &#123;</span><br><span class="line">					thread_move_ready(m, &amp;m-&gt;write, ev-&gt;write, THREAD_WRITE_ERROR);</span><br><span class="line">					ev-&gt;write = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (__test_bit(LOG_DETAIL_BIT, &amp;debug)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLRDHUP)</span><br><span class="line">						log_message(LOG_INFO, <span class="string">&quot;Received EPOLLRDHUP for fd %d&quot;</span>, ev-&gt;fd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 读事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ev-&gt;read) &#123;</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;scheduler: No read thread bound on fd:%d (fl:0x%.4X)&quot;</span></span><br><span class="line">						      , ev-&gt;fd, ep_ev-&gt;events);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 将读事件就绪的线程放到ready列表内 */</span></span><br><span class="line">				thread_move_ready(m, &amp;m-&gt;read, ev-&gt;read, THREAD_READY_READ_FD);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 置空表示读事件已被处理 */</span></span><br><span class="line">				ev-&gt;read = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 写事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLOUT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ev-&gt;write) &#123;</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;scheduler: No write thread bound on fd:%d (fl:0x%.4X)&quot;</span></span><br><span class="line">						      , ev-&gt;fd, ep_ev-&gt;events);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 将写事件就绪的线程放到ready列表内 */</span></span><br><span class="line">				thread_move_ready(m, &amp;m-&gt;write, ev-&gt;write, THREAD_READY_WRITE_FD);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 置空表示写事件已被处理 */</span></span><br><span class="line">				ev-&gt;write = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新time_now全局变量 */</span></span><br><span class="line">		set_time_now();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ready列表内不为空则返回 */</span></span><br><span class="line">		<span class="keyword">if</span> (m-&gt;ready.next != &amp;m-&gt;ready)</span><br><span class="line">			<span class="keyword">return</span> &amp;m-&gt;ready;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件的触发机制和定时机制分析"><a href="#事件的触发机制和定时机制分析" class="headerlink" title="事件的触发机制和定时机制分析"></a>事件的触发机制和定时机制分析</h2><h3 id="thread-timerfd-handler"><a href="#thread-timerfd-handler" class="headerlink" title="thread_timerfd_handler"></a>thread_timerfd_handler</h3><p>注意在<code>thread_make_master</code>函数中有<br><code>new-&gt;timer_thread = thread_add_read(new, thread_timerfd_handler, NULL, new-&gt;timer_fd, TIMER_NEVER, false);</code>，<br>这会创建一个与定时任务相关的thread结构并放进master线程的read红黑树内，当超时后timerfd就会成为可读状态，进而可以通过<br>epoll监听该定时事件，并调用回调函数<code>thread_timerfd_handler</code>。</p>
<p>定时任务的超时时间一开始被设置为<code>TIMER_NEVER</code>，表示该事件永远不会被调度，即定时并不是在此时开始的，真正开始计时是<br>在上面的<code>thread_set_timer</code>函数内通过<code>timerfd_settime</code>开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">定时任务超时后的回调函数</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">thread_timerfd_handler</span><span class="params">(<span class="type">thread_ref_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_master_t</span> *m = thread-&gt;master;</span><br><span class="line">	<span class="type">uint64_t</span> expired;</span><br><span class="line">	<span class="type">ssize_t</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read返回则表明已超出设定时间 */</span></span><br><span class="line">	len = read(m-&gt;timer_fd, &amp;expired, <span class="keyword">sizeof</span>(expired));</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">		log_message(LOG_ERR, <span class="string">&quot;scheduler: Error reading on timerfd fd:%d (%m)&quot;</span>, m-&gt;timer_fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read、write、timer、child线程中，将已就绪的线程放到ready列表内，之后会被thread_fetch_next_queue取得，</span></span><br><span class="line"><span class="comment">	进而调用其各自回调 */</span></span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;read, THREAD_READ_TIMEOUT);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;write, THREAD_WRITE_TIMEOUT);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;timer, THREAD_READY);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;child, THREAD_CHILD_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前定时任务执行完毕，添加下一个定时任务 */</span></span><br><span class="line">	m-&gt;timer_thread = thread_add_read(m, thread_timerfd_handler, <span class="literal">NULL</span>, m-&gt;timer_fd, TIMER_NEVER, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-set-timer"><a href="#thread-set-timer" class="headerlink" title="thread_set_timer"></a>thread_set_timer</h3><p>只有通过该函数，定时任务才会真正的开始计时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_set_timer</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">timeval_t</span> timer_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">its</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里是读取timer、write、read、child四个红黑树，比较其时间沙的值，</span></span><br><span class="line"><span class="comment">	将其中定时任务最近的时间赋值给timer_wait */</span></span><br><span class="line">	timerclear(&amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;timer, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;write, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;read, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;child, &amp;timer_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timerisset(&amp;timer_wait)) &#123;</span><br><span class="line">		<span class="comment">/* 已从四个红黑树中读取到一个最近的时间 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 再次设置time_now，保证精确度 */</span></span><br><span class="line">		set_time_now();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置timer_wait = timer_wait - time_now */</span></span><br><span class="line">		timersub(&amp;timer_wait, &amp;time_now, &amp;timer_wait);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timer_wait.tv_sec &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 定时任务发生在过去，清除timer_wait */</span></span><br><span class="line">			timerclear(&amp;timer_wait);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 走到这里一般表明红黑树中没有开启定时任务的事件，将其超时时间设置为一个非常长的时间 */</span></span><br><span class="line">		timer_wait.tv_sec = LONG_MAX;</span><br><span class="line">		timer_wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	its.it_value.tv_sec = timer_wait.tv_sec;</span><br><span class="line">	<span class="keyword">if</span> (!timerisset(&amp;timer_wait)) &#123;</span><br><span class="line">		<span class="comment">/* 如果之前定时任务发生在过去，实际超时时间会被设置为0秒1纳秒，这会很快触发其回调函数 */</span></span><br><span class="line">		its.it_value.tv_nsec = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		its.it_value.tv_nsec = timer_wait.tv_usec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 不设置时间间隔 */</span></span><br><span class="line">	its.it_interval.tv_sec = its.it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 开始计时 */</span></span><br><span class="line">	timerfd_settime(m-&gt;timer_fd, <span class="number">0</span>, &amp;its, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="thread-add-timer"><a href="#thread-add-timer" class="headerlink" title="thread_add_timer"></a>thread_add_timer</h3><p>添加一个线程到master-&gt;timer内，同样的，定时任务在设置后不会立即开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_timer</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> timer)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个thread结构 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_TIMER;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER)</span><br><span class="line">		<span class="comment">/* 定时任务关闭 */</span></span><br><span class="line">		thread-&gt;sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		<span class="comment">/* 设置线程时间沙的值为time_now + timer */</span></span><br><span class="line">		thread-&gt;sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序，插入timer红黑树内 */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;timer, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-add-read"><a href="#thread-add-read" class="headerlink" title="thread_add_read"></a>thread_add_read</h3><p>添加一个线程到master-&gt;read内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_read</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> timer, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">timeval_t</span> sands;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算read线程超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER) &#123;</span><br><span class="line">		sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">		sands.tv_usec = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread_add_read_sands(m, func, arg, fd, &amp;sands, close_on_reload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建线程，添加到master-&gt;read内 */</span></span><br><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_read_sands</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">const</span> <span class="type">timeval_t</span> *sands, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_event_t</span> *event;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果先前设置了current_event，这会加速event的初始化流程 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;current_event &amp;&amp; m-&gt;current_event-&gt;fd == fd)</span><br><span class="line">		event = m-&gt;current_event;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 先前已创建了该事件，尝试从master-&gt;io_events内读取该事件，这同样会加速event初始化流程 */</span></span><br><span class="line">		event = thread_event_get(m, fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!event) &#123;</span><br><span class="line">		<span class="comment">/* 第一次触发事件，通过thread_event_new创建一个event对象，并添加到master-&gt;io_events内,这是一个较慢</span></span><br><span class="line"><span class="comment">		的流程 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(event = thread_event_new(m, fd))) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant allocate read event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__test_bit(THREAD_FL_READ_BIT, &amp;event-&gt;flags) &amp;&amp; event-&gt;read) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: There is already read event %p (read %p) registered on fd [%d]&quot;</span>, event, event-&gt;read, fd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个read线程 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_READ;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.f.fd = fd;</span><br><span class="line">	thread-&gt;u.f.close_on_reload = close_on_reload;</span><br><span class="line">	thread-&gt;event = event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置READ flag */</span></span><br><span class="line">	__set_bit(THREAD_FL_READ_BIT, &amp;event-&gt;flags);</span><br><span class="line"></span><br><span class="line">	event-&gt;read = thread;</span><br><span class="line">	<span class="keyword">if</span> (!__test_bit(THREAD_FL_EPOLL_READ_BIT, &amp;event-&gt;flags)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过epoll_ctl添加EPOLLIN事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_event_set(thread) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant register read event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			thread_add_unuse(m, thread);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_bit(THREAD_FL_EPOLL_READ_BIT, &amp;event-&gt;flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	thread-&gt;sands = *sands;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序插入master-&gt;read */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;read, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-add-write"><a href="#thread-add-write" class="headerlink" title="thread_add_write"></a>thread_add_write</h3><p>创建并添加一个线程到master-&gt;write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_write</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> timer, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_event_t</span> *event;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果先前设置了current_event，这会加速event的初始化流程 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;current_event &amp;&amp; m-&gt;current_event-&gt;fd == fd)</span><br><span class="line">		event = m-&gt;current_event;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 先前已创建了该事件，尝试从master-&gt;io_events内读取该事件，这同样会加速event初始化流程 */</span></span><br><span class="line">		event = thread_event_get(m, fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!event) &#123;</span><br><span class="line">		<span class="comment">/* 第一次触发事件，通过thread_event_new创建一个event对象，并添加到master-&gt;io_events内,这是一个较慢</span></span><br><span class="line"><span class="comment">		的流程 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(event = thread_event_new(m, fd))) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant allocate write event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__test_bit(THREAD_FL_WRITE_BIT, &amp;event-&gt;flags) &amp;&amp; event-&gt;write) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: There is already write event registered on fd [%d]&quot;</span>, fd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个write线程 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_WRITE;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.f.fd = fd;</span><br><span class="line">	thread-&gt;u.f.close_on_reload = close_on_reload;</span><br><span class="line">	thread-&gt;event = event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置WRITE flag */</span></span><br><span class="line">	__set_bit(THREAD_FL_WRITE_BIT, &amp;event-&gt;flags);</span><br><span class="line">	event-&gt;write = thread;</span><br><span class="line">	<span class="keyword">if</span> (!__test_bit(THREAD_FL_EPOLL_WRITE_BIT, &amp;event-&gt;flags)) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 通过epoll_ctl添加EPOLLOUT事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_event_set(thread) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant register write event for fd [%d](%m)&quot;</span> , fd);</span><br><span class="line">			thread_add_unuse(m, thread);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_bit(THREAD_FL_EPOLL_WRITE_BIT, &amp;event-&gt;flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER)</span><br><span class="line">		thread-&gt;sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		thread-&gt;sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序插入master-&gt;write */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;write, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与lvs的通信"><a href="#与lvs的通信" class="headerlink" title="与lvs的通信"></a>与lvs的通信</h2><h3 id="ipvs-init"><a href="#ipvs-init" class="headerlink" title="ipvs_init"></a>ipvs_init</h3><p><code>ipvs_init</code>由<code>ipvs_start</code>在健康检查子进程中被调用，其主要负责ipvs模块的加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ipvs_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	log_message(LOG_DEBUG, <span class="string">&quot;%snitializing ipvs&quot;</span>, reload ? <span class="string">&quot;Rei&quot;</span> : <span class="string">&quot;I&quot;</span>);</span><br><span class="line">	<span class="comment">/* 初始化ipvs模块 */</span></span><br><span class="line">	<span class="keyword">if</span> (ipvs_init()) &#123;</span><br><span class="line">		<span class="comment">/* ipvs模块未加载，通过modprobe加载ipvs模块，重新进行初始化 */</span></span><br><span class="line">		<span class="keyword">if</span> (keepalived_modprobe(<span class="string">&quot;ip_vs&quot;</span>) || ipvs_init()) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;IPVS: Can&#x27;t initialize ipvs: %s&quot;</span>,</span><br><span class="line">			       ipvs_strerror(errno));</span><br><span class="line">			no_ipvs = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> IPVS_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IPVS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipvs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_getinfo</span> <span class="title">ipvs_info</span>;</span></span><br><span class="line"></span><br><span class="line">	ipvs_func = ipvs_init;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过socket和内核通信 */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_RAW | SOCK_CLOEXEC, IPPROTO_RAW)) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(ipvs_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 得到ipvs_info，内部包含ipvs版本号、连接表大小、虚服务数量三个信息 */</span></span><br><span class="line">	<span class="keyword">if</span> (getsockopt(sockfd, IPPROTO_IP, IP_VS_SO_GET_INFO, (<span class="type">char</span> *)&amp;ipvs_info, &amp;len)) &#123;</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="init-services"><a href="#init-services" class="headerlink" title="init_services"></a>init_services</h3><p>init_services方法用来完成lvs虚服务和实服务的添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">init_services</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	element e;</span><br><span class="line">	<span class="type">virtual_server_t</span> *vs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历vs列表，初始化每个虚服务 */</span></span><br><span class="line">	LIST_FOREACH(check_data-&gt;vs, vs, e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!init_service_vs(vs))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_service_vs</span><span class="params">(<span class="type">virtual_server_t</span> * vs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ISALIVE(vs) || vs-&gt;vsg) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过setsockopt(sockfd, IPPROTO_IP, IP_VS_SO_SET_ADD, (char *)svc,</span></span><br><span class="line"><span class="comment">			sizeof(struct ip_vs_service_user))，内核会调用ipvs_add_service添加一个虚服务 */</span></span><br><span class="line">		ipvs_cmd(LVS_CMD_ADD, vs, <span class="literal">NULL</span>);</span><br><span class="line">		SET_ALIVE(vs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 同样的，利用setsockopt添加实服务 */</span></span><br><span class="line">	<span class="keyword">if</span> (!init_service_rs(vs))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vs-&gt;reloaded &amp;&amp; vs-&gt;vsgname) &#123;</span><br><span class="line">		<span class="comment">/* add reloaded dests into new vsg entries */</span></span><br><span class="line">		sync_service_vsg(vs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置vs-&gt;quorum_state_up为true */</span></span><br><span class="line">	update_quorum_state(vs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加上sorry server */</span></span><br><span class="line">	<span class="keyword">if</span> (vs-&gt;s_svr &amp;&amp; vs-&gt;s_svr-&gt;inhibit &amp;&amp; !vs-&gt;s_svr-&gt;<span class="built_in">set</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vs-&gt;s_svr_duplicates_rs)</span><br><span class="line">			vs-&gt;s_svr-&gt;<span class="built_in">set</span> = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			vs-&gt;s_svr-&gt;num_failed_checkers = <span class="number">1</span>;</span><br><span class="line">			ipvs_cmd(LVS_CMD_ADD_DEST, vs, vs-&gt;s_svr);</span><br><span class="line">			vs-&gt;s_svr-&gt;num_failed_checkers = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="update-svr-checker-state"><a href="#update-svr-checker-state" class="headerlink" title="update_svr_checker_state"></a>update_svr_checker_state</h3><p>健康检查成功或失败时，会调用<code>update_svr_checker_state</code>更新checker状态，添加或删除实服务</p>
<p>在首次运行健康检查时，如果没有开启alpha模式，虚服务对应的实服务会都被添加到lvs上，若此时对应<br>的健康检查也成功，则下方会在第一个if代码块内返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">update_svr_checker_state</span><span class="params">(<span class="type">bool</span> alive, <span class="type">checker_t</span> *checker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 健康检查开启且检查成功 或 健康检查关闭且检查失败 */</span></span><br><span class="line">	<span class="keyword">if</span> (checker-&gt;is_up == alive) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!checker-&gt;has_run) &#123;</span><br><span class="line">			<span class="comment">/* 首次运行健康检查 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (checker-&gt;alpha || !alive)</span><br><span class="line">				<span class="comment">/* alpha模式开启或此次健康检查失败 */</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 调用notify_up或notify_down脚本 */</span></span><br><span class="line">				do_rs_notifies(checker-&gt;vs, checker-&gt;rs, <span class="literal">false</span>);</span><br><span class="line">			checker-&gt;has_run = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 走到这里表明我们可能需要添加或删除实服务器 */</span></span><br><span class="line"></span><br><span class="line">	checker-&gt;has_run = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alive) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 此次健康检查成功，且对当前rs的健康检查失败次数小于等于1，防止重复添加rs */</span></span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;rs-&gt;num_failed_checkers &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前rs添加到lvs */</span></span><br><span class="line">			<span class="keyword">if</span> (!perform_svr_state(<span class="literal">true</span>, checker))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 健康检查失败，且当前实服务器的健康检查失败个数为0，防止重复移除rs */</span></span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;rs-&gt;num_failed_checkers == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!perform_svr_state(<span class="literal">false</span>, checker))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新checker状态 */</span></span><br><span class="line">	set_checker_state(checker, alive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/15/lvs%E4%BC%9A%E8%AF%9D%E5%90%8C%E6%AD%A5/" rel="prev" title="lvs会话同步">
                  <i class="fa fa-angle-left"></i> lvs会话同步
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="jemalloc源码分析">
                  jemalloc源码分析 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Aaron Zhao</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">21k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:15</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
