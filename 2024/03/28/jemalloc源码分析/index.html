<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zy-aaron.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="version: 5.1.0 how to use it在编译项目时链接上jemalloc库即可，gcc project.c -o project -ljemalloc &#96;jemalloc-config –libs&#96;，之后项目中所有使用malloc或者calloc等动态内存分配的地方都会自动替换为jemalloc内的实现 传统内存分配器的主要性能瓶颈 竞态条件 内存碎片问题  对于多线程环境下锁竞">
<meta property="og:type" content="article">
<meta property="og:title" content="jemalloc源码分析">
<meta property="og:url" content="https://zy-aaron.github.io/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="赵耀的博客">
<meta property="og:description" content="version: 5.1.0 how to use it在编译项目时链接上jemalloc库即可，gcc project.c -o project -ljemalloc &#96;jemalloc-config –libs&#96;，之后项目中所有使用malloc或者calloc等动态内存分配的地方都会自动替换为jemalloc内的实现 传统内存分配器的主要性能瓶颈 竞态条件 内存碎片问题  对于多线程环境下锁竞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zy-aaron.github.io/png/data-structure.drawio.png">
<meta property="og:image" content="https://zy-aaron.github.io/png/jemalloc-flowchart.png">
<meta property="article:published_time" content="2024-03-28T09:43:09.000Z">
<meta property="article:modified_time" content="2024-09-01T06:44:42.322Z">
<meta property="article:author" content="Aaron Zhao">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zy-aaron.github.io/png/data-structure.drawio.png">


<link rel="canonical" href="https://zy-aaron.github.io/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zy-aaron.github.io/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","path":"2024/03/28/jemalloc源码分析/","title":"jemalloc源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>jemalloc源码分析 | 赵耀的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">赵耀的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#how-to-use-it"><span class="nav-number">1.</span> <span class="nav-text">how to use it</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">2.</span> <span class="nav-text">传统内存分配器的主要性能瓶颈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-function-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">malloc function(单线程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jemalloc%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">jemalloc主要数据结构及关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%A6%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">简要函数调用关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">malloc过程分析：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#je-malloc"><span class="nav-number">6.1.</span> <span class="nav-text">je_malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">malloc的初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#b0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">b0的初始化流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">a0的初始化流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-tsd-boot0"><span class="nav-number">6.2.3.</span> <span class="nav-text">malloc_tsd_boot0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#arena-extent-alloc-large-%E5%88%86%E9%85%8D%E5%A4%A7%E5%86%85%E5%AD%98"><span class="nav-number">6.2.4.</span> <span class="nav-text">arena_extent_alloc_large 分配大内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#imalloc-body-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.3.</span> <span class="nav-text">imalloc_body 分配内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#imalloc-no-sample"><span class="nav-number">6.3.1.</span> <span class="nav-text">imalloc_no_sample</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free%E8%BF%87%E7%A8%8B%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">free过程简要分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#free-function"><span class="nav-number">7.1.</span> <span class="nav-text">free function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">总结：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aaron Zhao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1946697015@qq.com" title="E-Mail → mailto:1946697015@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="jemalloc源码分析 | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jemalloc源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-28 17:43:09" itemprop="dateCreated datePublished" datetime="2024-03-28T17:43:09+08:00">2024-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 14:44:42" itemprop="dateModified" datetime="2024-09-01T14:44:42+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jemalloc/" itemprop="url" rel="index"><span itemprop="name">jemalloc</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>version: 5.1.0</p>
<h2 id="how-to-use-it"><a href="#how-to-use-it" class="headerlink" title="how to use it"></a>how to use it</h2><p>在编译项目时链接上jemalloc库即可，gcc project.c -o project -ljemalloc `jemalloc-config –libs`，<br>之后项目中所有使用malloc或者calloc等动态内存分配的地方都会自动替换为jemalloc内的实现</p>
<h2 id="传统内存分配器的主要性能瓶颈"><a href="#传统内存分配器的主要性能瓶颈" class="headerlink" title="传统内存分配器的主要性能瓶颈"></a>传统内存分配器的主要性能瓶颈</h2><ol>
<li>竞态条件</li>
<li>内存碎片问题</li>
</ol>
<p>对于多线程环境下锁竞争的问题，jemalloc使用线程特定数据(thread specific data)来缓解，<br>并通过线程特定缓存(thread specific cache)提升性能。<br>关于内存碎片问题，jemalloc根据用户要求分配的内存空间的大小采取不同的分配方案：小内存的分配属于small class，<br>这些内存被slab按组管理，每个slab包含一个位图(bitmap)用于跟踪分配的内存情况；大内存(large class)则使用<br>extent管理内存的分配与释放。<br>实际的内存分配是通过mmap和sbrk完成的，mmap是默认优先采取的方法，在系统支持sbrk的前提下，仅当mmap分配失败时才会尝试使用sbrk分配</p>
<h2 id="malloc-function-单线程"><a href="#malloc-function-单线程" class="headerlink" title="malloc function(单线程)"></a>malloc function(单线程)</h2><p>下面是单线程场景下的jemalloc调用流程：</p>
<ol>
<li>执行jemalloc初始化，这一步在main函数执行前执行，也就是说，在执行用户的内存分配函数前，系统首先处理自动分配的内存(测试环境下为72704)，<br>并完成初始化的过程。</li>
<li>在初始化流程中，系统会完成初期的内存分配工作(主要指一些元数据的内存分配，例如b0和a0)，完成了与当前线程相关的tsd的初始化和tcache中bins的分配，并初始化一系列全局变量用于后续的内存分配</li>
<li>初始化完成，进入后续内存分配阶段，注意此时仍处于系统自动分配内存阶段，即进入main函数前，由于要求分配的内存大小为72704，属于large class，所以应当使用extent分配。我们在初始化时已经为a0分配了一个base即b0(用于为extent分配空间)，jemalloc首先尝试复用已有的extent，当前并没有这样的extent，所以其会从base中再分配一个符合当前大小的extent，之后将当前size对齐到2M（测试中大小为2097152），通过extent_alloc_core为extent分配这样的一块空间用于管理，其中extent_alloc_core会根据当前配置选择使用mmap或sbrk；若当前base的空间不足以再分配一个extent，则通过base_block_alloc分配一个base_block_t大小的内存，并从中为extent分配内存。</li>
<li>接下来系统初期malloc完成，进入main函数，程序将根据当前要求分配的大小，从tcache或arena-&gt;extents中分配内存</li>
</ol>
<h2 id="jemalloc主要数据结构及关系"><a href="#jemalloc主要数据结构及关系" class="headerlink" title="jemalloc主要数据结构及关系"></a><code>jemalloc</code>主要数据结构及关系</h2><p>arena:<br>为内存分配的核心结构，内部包含tcache的链表，根据extents的不同类型，有三种不同的extents类别分别管理，同时也<br>通过rtree管理extent的空闲表，对于小内存则由内部的bins管理分配，由base负责内部extent的内存分配，arena_decay_t结构则负责gc的管理。</p>
<p>base:<br>负责arena元数据的分配，内部有一个base_block_t类型的链表用于存储初始化阶段分配的内存，对于arena中三种extents类型，每个extents的extent内存分配都依赖base，若当前base空间不够，则会再分配一个base_block_t类型用于内存分配。</p>
<p>extents:<br>用于大内存分配和tcache初始化，有extents_dirty，extents_muzzy，extents_retained三种类型，gc会从前一种类型<br>转为后一种，内部有lru链表用于追踪heaps内的extent，bitmap用于快速定位heaps中extent的位置，delay_coalesce标记<br>当前extents是否采用延迟联合，若是则内存分配策略采用best-fit，并延迟联合过程，否则采用first-fit。</p>
<p>extent:<br>分配内存的容器，为了提高效率采用了uint64_t类型的整数e_bits，其不同的bit表示extent的状态，e_addr则是当前extent对应的<br>内存，同时也保存了内存大小</p>
<p>tsd:<br>线程本地数据，存储当前线程相关的数据</p>
<p>tcache:<br>线程本地缓存，如果当前分配的size为small class，则从tcache的bins_small或bins_large中分配</p>
<p><img src="/png/data-structure.drawio.png" alt="数据结构"></p>
<h2 id="简要函数调用关系图"><a href="#简要函数调用关系图" class="headerlink" title="简要函数调用关系图"></a>简要函数调用关系图</h2><p><img src="/./png/jemalloc-flowchart.png" alt="流程图"></p>
<h2 id="malloc过程分析："><a href="#malloc过程分析：" class="headerlink" title="malloc过程分析："></a>malloc过程分析：</h2><h3 id="je-malloc"><a href="#je-malloc" class="headerlink" title="je_malloc"></a>je_malloc</h3><p>用于<code>malloc</code>分配内存的主函数，其内部主要对<code>static_opts_t</code>和<code>dynamic_opts_t</code>两个变量进行了初始化，这些变量主要记录了当前内存分配的一些必要<br>信息和属性，真正的内存分配工作由<code>imalloc</code>完成</p>
<ul>
<li><p>关于<code>static_opts_t</code>:<br>主要定义了有关与内存分配的一些基本属性，例如在size为0时是否分配size为1的内存，出错时是否设置errno等，<br>其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_opts_s</span> &#123;</span></span><br><span class="line">	<span class="type">bool</span> may_overflow; <span class="comment">/* 分配的size是否会导致溢出 */</span></span><br><span class="line">	<span class="type">bool</span> bump_empty_alloc; <span class="comment">/* 若分配的size为0，是否将该size设置为1 */</span></span><br><span class="line">	<span class="type">bool</span> assert_nonempty_alloc; <span class="comment">/* 是否断言size != 0，即是否执行assert(size != 0) */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> null_out_result_on_error;</span><br><span class="line">	<span class="type">bool</span> set_errno_on_error;</span><br><span class="line">	<span class="type">size_t</span> min_alignment;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *oom_string;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *invalid_alignment_string;</span><br><span class="line">	<span class="type">bool</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>dynamic_opts_t</code>:<br>其内部存储着实际分配的内存和其他内存相关的属性，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamic_opts_s</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> **result; <span class="comment">/* 存储实际分配的内存 */</span></span><br><span class="line">	<span class="type">size_t</span> num_items;</span><br><span class="line">	<span class="type">size_t</span> item_size;</span><br><span class="line">	<span class="type">size_t</span> alignment;</span><br><span class="line">	<span class="type">bool</span> zero;</span><br><span class="line">	<span class="type">unsigned</span> tcache_ind;</span><br><span class="line">	<span class="type">unsigned</span> arena_ind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc的初始化过程"><a href="#malloc的初始化过程" class="headerlink" title="malloc的初始化过程"></a>malloc的初始化过程</h3><p>在使用gdb调试过程中发现，在执行测试demo前，malloc会先被自动调用一次，并完成malloc的初始化过程，在官方文档未找到<br>相关说明，关闭.&#x2F;configure 的debug模式和gcc -g选项没有影响，猜测应当是默认行为。此过程的malloc分配的大小为72704字节，属于large_class。</p>
<p>在程序第一次调用malloc时，通过对上述过程的调试发现，程序会首先检查malloc是已被成功初始化，若没有初始化，则会调用<code>malloc_init_hard</code>完成对malloc的初始化。</p>
<p>下面是<code>malloc_init_hard</code>部分代码，初始化成功后返回<code>false</code>:</p>
<p>函数内部使用了互斥锁来保证并发安全</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">malloc_init_hard</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">tsd_t</span> *tsd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 互斥锁，内部会调用pthread_mutex_trylock，获取失败时</span></span><br><span class="line"><span class="comment">	会尝试自旋一段时间，若仍未获取到则会调用pthread_mutex_lock */</span></span><br><span class="line">	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLOCK_RETURN(tsdn, ret, reentrancy)		\</span></span><br><span class="line"><span class="meta">	malloc_init_hard_cleanup(tsdn, reentrancy);	\</span></span><br><span class="line"><span class="meta">	return ret;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 判断是否应当进行hard初始化，如果已初始化或满足相关条件则解除</span></span><br><span class="line"><span class="comment">	互斥锁并退出，这里之所以反复判断初始化过程是考虑到并发情景下可能会</span></span><br><span class="line"><span class="comment">	有别的线程执行了初始化。malloc_init_hard_needed返回true就表明尚且没有</span></span><br><span class="line"><span class="comment">	别的线程完成初始化，所以只能由本线程继续初始化过程 */</span></span><br><span class="line">	<span class="keyword">if</span> (!malloc_init_hard_needed()) &#123;</span><br><span class="line">		UNLOCK_RETURN(TSDN_NULL, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* malloc_init_a0_initialized状态由malloc_init_hard_a0_locked函数设置，</span></span><br><span class="line"><span class="comment">	或被间接调用设置。malloc_init_hard_a0_locked函数内部将当前线程的id设置</span></span><br><span class="line"><span class="comment">	为锁标识malloc_initializer，这样保证了其他线程不会重复初始化malloc，所有的</span></span><br><span class="line"><span class="comment">	malloc初始化工作都将由当前线程执行。如果发生了上述的情形，则其他线程会在当前</span></span><br><span class="line"><span class="comment">	线程完成malloc初始化前一直自旋 </span></span><br><span class="line"><span class="comment">	除此之外，该函数主要完成了下列变量的初始化(以下为测试环境下的结果)：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	pagesize：4096				系统页大小，大于4096的页jemalloc暂不支持</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	mmap_flags : MAP_PRIVATE | MAP_ANON     用于mmap的标志，若os_overcommits为true，则再加上MAP_NORESERVE标志</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	os_overcommits: true			这里是判断当前操作系统的overcommit策略，true表示系统采用了0或1策略。</span></span><br><span class="line"><span class="comment">						overcommit发生在当系统申请的总内存超出linux设置的阈值时，通过</span></span><br><span class="line"><span class="comment">						读取/proc/sys/vm/overcommit_memory可获取当前系统overcommit策略。</span></span><br><span class="line"><span class="comment">						0: Heuristic overcommit.  表示根据内部算法，接受算法允许范围内的oom</span></span><br><span class="line"><span class="comment">						1: Always overcommit.	  表示总是允许申请内存</span></span><br><span class="line"><span class="comment">						2: Never overcommit.	  表示不允许申请内存</span></span><br><span class="line"><span class="comment">						内存的申请并不总是被完全使用，所以linux一般将内存的申请和分配</span></span><br><span class="line"><span class="comment">						分开来避免内存浪费，只有程序实际使用到时才会将内存进行分配。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	init_system_thp_mode: thp_mode_always	查看系统是否支持transparent huge page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	pages_can_purge_lazy_time: true		清理时是否可以lazy purge</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	extent_rtree				rtree</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	extent_mutex_pool			互斥锁池</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	dss_base				若系统支持sbrk，则通过sbrk初始化dss_base；分配器采用的默认内存分配优先级顺序是mmap-&gt;sbrk</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	ctl_initialized: false			与mallocctl相关</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	a0					即arenas[0]，单线程环境仅会使用a0进行内存分配</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (malloc_init_state != malloc_init_a0_initialized &amp;&amp;</span><br><span class="line">	    malloc_init_hard_a0_locked()) &#123;</span><br><span class="line">		UNLOCK_RETURN(TSDN_NULL, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 释放mutex锁，应当是出于减小锁粒度的考虑而没有全局加锁 */</span></span><br><span class="line">	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化tsd，内部初始化了tcache并为其bins分配内存，将在后文详细分析 */</span></span><br><span class="line">	tsd = malloc_tsd_boot0();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="b0的初始化流程"><a href="#b0的初始化流程" class="headerlink" title="b0的初始化流程"></a>b0的初始化流程</h4><p>b0是在<code>malloc_init_hard_a0_locked</code>完成初始化的，后续a0的初始化和tcache_bin_info的初始化均依赖b0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">base_t</span> *</span><br><span class="line"><span class="title function_">base_new</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">unsigned</span> ind, <span class="type">extent_hooks_t</span> *extent_hooks)</span> &#123;</span><br><span class="line">	<span class="type">pszind_t</span> pind_last = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> extent_sn_next = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 内部调用base_map分配内存，虽然这里传递的size大小是一个base_t的大小，但在调用</span></span><br><span class="line"><span class="comment">	base_map时会将其向上对齐到2M，用来减少不连续的内存，在去除头部和gap大小后，分配的剩余的</span></span><br><span class="line"><span class="comment">	内存会通过block-&gt;extent保存起来，供后续分配内存使用 */</span></span><br><span class="line">	<span class="type">base_block_t</span> *block = base_block_alloc(tsdn, <span class="literal">NULL</span>, extent_hooks, ind,</span><br><span class="line">	    &amp;pind_last, &amp;extent_sn_next, <span class="keyword">sizeof</span>(<span class="type">base_t</span>), QUANTUM);</span><br><span class="line">	<span class="keyword">if</span> (block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> gap_size;</span><br><span class="line">	<span class="type">size_t</span> base_alignment = CACHELINE;</span><br><span class="line">	<span class="type">size_t</span> base_size = ALIGNMENT_CEILING(<span class="keyword">sizeof</span>(<span class="type">base_t</span>), base_alignment);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里是从block-&gt;extent给base结构分配内存，分配完毕后更新extent，extent-&gt;e_addr为对齐后的去除base_size的大小 */</span></span><br><span class="line">	<span class="type">base_t</span> *base = (<span class="type">base_t</span> *)base_extent_bump_alloc_helper(&amp;block-&gt;extent,</span><br><span class="line">	    &amp;gap_size, base_size, base_alignment);</span><br><span class="line">	base-&gt;ind = ind;</span><br><span class="line">	atomic_store_p(&amp;base-&gt;extent_hooks, extent_hooks, ATOMIC_RELAXED);</span><br><span class="line">	<span class="keyword">if</span> (malloc_mutex_init(&amp;base-&gt;mtx, <span class="string">&quot;base&quot;</span>, WITNESS_RANK_BASE,</span><br><span class="line">	    malloc_mutex_rank_exclusive)) &#123;</span><br><span class="line">		base_unmap(tsdn, extent_hooks, ind, block, block-&gt;size);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	base-&gt;pind_last = pind_last;</span><br><span class="line">	base-&gt;extent_sn_next = extent_sn_next;</span><br><span class="line">	base-&gt;blocks = block;</span><br><span class="line">	base-&gt;auto_thp_switched = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/* 初始化base-&gt;avail，这是用来跟踪blocks中的extent heap */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">szind_t</span> i = <span class="number">0</span>; i &lt; NSIZES; i++) &#123;</span><br><span class="line">		extent_heap_new(&amp;base-&gt;avail[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 更新extent heap */</span></span><br><span class="line">	base_extent_bump_alloc_post(base, &amp;block-&gt;extent, gap_size, base,</span><br><span class="line">	    base_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="a0的初始化流程"><a href="#a0的初始化流程" class="headerlink" title="a0的初始化流程"></a>a0的初始化流程</h4><p>主要就是从base的extent heap中分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> *</span><br><span class="line"><span class="title function_">arena_new</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">unsigned</span> ind, <span class="type">extent_hooks_t</span> *extent_hooks)</span> &#123;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line">	<span class="type">base_t</span> *base;</span><br><span class="line">	<span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 取得b0 */</span></span><br><span class="line">	<span class="keyword">if</span> (ind == <span class="number">0</span>) &#123;</span><br><span class="line">		base = b0get();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		base = base_new(tsdn, ind, extent_hooks);</span><br><span class="line">		<span class="keyword">if</span> (base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 初始化arena，从base的avail数组中挑出一个extent，并为arena分配空间，和CACHELINE对齐 */</span></span><br><span class="line">	arena = (<span class="type">arena_t</span> *)base_alloc(tsdn, base, <span class="keyword">sizeof</span>(<span class="type">arena_t</span>), CACHELINE);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="malloc-tsd-boot0"><a href="#malloc-tsd-boot0" class="headerlink" title="malloc_tsd_boot0"></a>malloc_tsd_boot0</h4><p>这是初始化tsd的方法，同时也影响了arena的extent，tsd对后续的内存分配十分重要</p>
<ul>
<li>tsd: thread specific data</li>
<li>tls: thread local storage</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">malloc_tsd_boot0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">tsd_t</span> *tsd;</span><br><span class="line"></span><br><span class="line">	ncleanups = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 通过pthread_key_create创建一个tsd key，并赋值给tsd_tsd */</span>	</span><br><span class="line">	<span class="keyword">if</span> (tsd_boot0()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* tsd_fetch取得当前线程的tsd，并初始化内部的tcache等变量 */</span></span><br><span class="line">	tsd = tsd_fetch();</span><br><span class="line">	<span class="comment">/* 设置tsd的arenas_tdata_bypass为true */</span></span><br><span class="line">	*tsd_arenas_tdata_bypassp_get(tsd) = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tsd_fetch调用下面的函数：由于是第一次获取tsd，所以走的是slow path */</span></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">tsd_fetch_impl</span><span class="params">(<span class="type">bool</span> init, <span class="type">bool</span> minimal)</span> &#123;	</span><br><span class="line"></span><br><span class="line">	<span class="type">tsd_t</span> *tsd = tsd_get(init);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init &amp;&amp; tsd_get_allocates() &amp;&amp; tsd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(tsd != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsd-&gt;state != tsd_state_nominal)) &#123;</span><br><span class="line">		<span class="comment">/* 在这里调用tsd_fetch_slow */</span></span><br><span class="line">		<span class="keyword">return</span> tsd_fetch_slow(tsd, minimal);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(tsd_fast(tsd));</span><br><span class="line">	tsd_assert_fast(tsd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">tsd_fetch_slow</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">bool</span> minimal)</span> &#123;</span><br><span class="line">	assert(!tsd_fast(tsd));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据tsd的state，第一次会走下面这个分支 */</span></span><br><span class="line">	<span class="keyword">if</span> (tsd-&gt;state == tsd_state_uninitialized) &#123;</span><br><span class="line">		<span class="comment">/* minimal为false */</span></span><br><span class="line">		<span class="keyword">if</span> (!minimal) &#123;</span><br><span class="line">			tsd-&gt;state = tsd_state_nominal;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* tsd_slow_update在首次初始化时将tsd的state设置为tsd_state_nominal_slow */</span></span><br><span class="line">			tsd_slow_update(tsd);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Trigger cleanup handler registration. */</span></span><br><span class="line">			<span class="comment">/* 在内部通过pthread_setspecific设置线程私有数据为tsd_tls */</span></span><br><span class="line">			tsd_set(tsd);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 内部初始化了rtree context，用于后面初始化tcache；</span></span><br><span class="line"><span class="comment">			调用了tsd_tcache_enabled_data_init用于对tsd进一步初始化，tsd_tcache_enabled_data_init</span></span><br><span class="line"><span class="comment">			内部开启了tsd tcache，之后通过tsd_tcache_data_init初始化tcache */</span></span><br><span class="line">			tsd_data_init(tsd);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tsd-&gt;state = tsd_state_minimal_initialized;</span><br><span class="line">			tsd_set(tsd);</span><br><span class="line">			tsd_data_init_nocleanup(tsd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完成对tcache的初始化 */</span></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">tsd_tcache_data_init</span><span class="params">(<span class="type">tsd_t</span> *tsd)</span> &#123;</span><br><span class="line">	<span class="comment">/* 拿到tsd内部的tcache */</span></span><br><span class="line">	<span class="type">tcache_t</span> *tcache = tsd_tcachep_get_unsafe(tsd);</span><br><span class="line">	assert(tcache_small_bin_get(tcache, <span class="number">0</span>)-&gt;avail == <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 得到当前tcache的栈空间大小size，测试环境下为24768 */</span>	</span><br><span class="line">	<span class="type">size_t</span> size = stack_nelms * <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	<span class="comment">/* Avoid false cacheline sharing. */</span></span><br><span class="line">	<span class="comment">/* 考虑到字节对齐等因素，计算得到当前能使用的大小，测试环境下为28672 */</span></span><br><span class="line">	size = sz_sa2u(size, CACHELINE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arena_get从arenas数组得到index为0的arena，arenas是一个全局数组，在</span></span><br><span class="line"><span class="comment">	前面的malloc_init_hard_a0_locked通过memset初始化为0。此处的avail_array</span></span><br><span class="line"><span class="comment">	由a0通过arena_extent_alloc_large分配，后文会详细介绍这个函数 */</span></span><br><span class="line">	<span class="type">void</span> *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, <span class="literal">true</span>,</span><br><span class="line">	    <span class="literal">NULL</span>, <span class="literal">true</span>, arena_get(TSDN_NULL, <span class="number">0</span>, <span class="literal">true</span>));</span><br><span class="line">	<span class="keyword">if</span> (avail_array == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 根据avail_array地址分配tcache-&gt;bins_small-&gt;avail的和tcache-&gt;bins_large-&gt;avail的</span></span><br><span class="line"><span class="comment">	内存，下面的注释也说明了这里的tcache初始化已经在malloc_init()这一步完成过了，</span></span><br><span class="line"><span class="comment">	但出于一些原因仍初始化一遍 */</span></span><br><span class="line">	tcache_init(tsd, tcache, avail_array);</span><br><span class="line">	tcache-&gt;arena = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line">	<span class="keyword">if</span> (!malloc_initialized()) &#123;</span><br><span class="line">		<span class="comment">/* If in initialization, assign to a0. */</span></span><br><span class="line">		arena = arena_get(tsd_tsdn(tsd), <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">/* 将tcache和arena关联起来 */</span>		</span><br><span class="line">		tcache_arena_associate(tsd_tsdn(tsd), tcache, arena);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arena = arena_choose(tsd, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/* This may happen if thread.tcache.enabled is used. */</span></span><br><span class="line">		<span class="keyword">if</span> (tcache-&gt;arena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			tcache_arena_associate(tsd_tsdn(tsd), tcache, arena);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(arena == tcache-&gt;arena);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="arena-extent-alloc-large-分配大内存"><a href="#arena-extent-alloc-large-分配大内存" class="headerlink" title="arena_extent_alloc_large 分配大内存"></a>arena_extent_alloc_large 分配大内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">arena_extent_alloc_large</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> usize,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span> &#123;</span><br><span class="line">	<span class="type">extent_hooks_t</span> *extent_hooks = EXTENT_HOOKS_INITIALIZER;</span><br><span class="line"></span><br><span class="line">	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),</span><br><span class="line">	    WITNESS_RANK_CORE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">szind_t</span> szind = sz_size2index(usize);</span><br><span class="line">	<span class="type">size_t</span> mapped_add;</span><br><span class="line">	<span class="type">bool</span> commit = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 首先尝试从extents_dirty分配 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extents_alloc(tsdn, arena, &amp;extent_hooks,</span><br><span class="line">	    &amp;arena-&gt;extents_dirty, <span class="literal">NULL</span>, usize, sz_large_pad, alignment, <span class="literal">false</span>,</span><br><span class="line">	    szind, zero, &amp;commit);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 再尝试从extents_muzzy分配 */</span></span><br><span class="line">		extent = extents_alloc(tsdn, arena, &amp;extent_hooks,</span><br><span class="line">		    &amp;arena-&gt;extents_muzzy, <span class="literal">NULL</span>, usize, sz_large_pad, alignment,</span><br><span class="line">		    <span class="literal">false</span>, szind, zero, &amp;commit);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> size = usize + sz_large_pad;</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 最后调用extent_alloc_wrapper方法，从b0为extent_retained分配内存，并调用mmap或sbrk为extent_retained-&gt;</span></span><br><span class="line"><span class="comment">		e_addr分配内存 */</span></span><br><span class="line">		extent = extent_alloc_wrapper(tsdn, arena, &amp;extent_hooks, <span class="literal">NULL</span>,</span><br><span class="line">		    usize, sz_large_pad, alignment, <span class="literal">false</span>, szind, zero,</span><br><span class="line">		    &amp;commit);</span><br><span class="line">		<span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * extent may be NULL on OOM, but in that case</span></span><br><span class="line"><span class="comment">			 * mapped_add isn&#x27;t used below, so there&#x27;s no need to</span></span><br><span class="line"><span class="comment">			 * conditionlly set it to 0 here.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mapped_add = size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">		mapped_add = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数调用过程过于复杂，此处仅列出最后分配内存的部分和调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipallocztm -&gt; je_arena_palloc -&gt; je_large_malloc -&gt; je_large_palloc -&gt;</span><br><span class="line">je_arena_extent_alloc_wrapper -&gt; extent_alloc_retained -&gt; extent_grow_retained -&gt;</span><br><span class="line">extent_alloc_default_impl -&gt; extent_alloc_core -&gt; je_extent_alloc_mmap -&gt;</span><br><span class="line">pages_mmap -&gt; os_pages_mmap</span><br></pre></td></tr></table></figure>

<p>至此初始化基本完成，初始化完成后，调用<code>imalloc_body</code>进行实际内存分配，注意此时分配的大小仍是系统自动调用的malloc分配的大小即72704，main函数尚未开始运行。</p>
<h3 id="imalloc-body-分配内存"><a href="#imalloc-body-分配内存" class="headerlink" title="imalloc_body 分配内存"></a>imalloc_body 分配内存</h3><p>内部调用<code>imalloc_no_sample</code>进行内存分配，下面是部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">int</span></span><br><span class="line"><span class="title function_">imalloc_body</span><span class="params">(<span class="type">static_opts_t</span> *sopts, <span class="type">dynamic_opts_t</span> *dopts, <span class="type">tsd_t</span> *tsd)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *allocation = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">szind_t</span> ind = <span class="number">0</span>;    <span class="comment">/* 用于未对齐情况 */</span></span><br><span class="line">	<span class="type">size_t</span> usize = <span class="number">0</span>;   <span class="comment">/* 用于对齐情况 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reentrancy is only checked on slow path. */</span></span><br><span class="line">	<span class="type">int8_t</span> reentrancy_level;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* This is the beginning of the &quot;core&quot; algorithm. */</span></span><br><span class="line">	<span class="comment">/* 计算usize */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;alignment == <span class="number">0</span>) &#123;</span><br><span class="line">		ind = sz_size2index(size);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ind &gt;= NSIZES)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (config_stats || (config_prof &amp;&amp; opt_prof)) &#123;</span><br><span class="line">			usize = sz_index2size(ind);</span><br><span class="line">			assert(usize &gt; <span class="number">0</span> &amp;&amp; usize &lt;= LARGE_MAXCLASS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		usize = sz_sa2u(size, dopts-&gt;alignment);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(usize == <span class="number">0</span> || usize &gt; LARGE_MAXCLASS)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* If profiling is on, get our profiling context. */</span></span><br><span class="line">	<span class="keyword">if</span> (config_prof &amp;&amp; opt_prof) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 通过imalloc_no_sample得到分配的内存，后文会介绍此函数 */</span></span><br><span class="line">		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,</span><br><span class="line">		    ind);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(allocation == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* Success! */</span></span><br><span class="line">	check_entry_exit_locking(tsd_tsdn(tsd));</span><br><span class="line">	*dopts-&gt;result = allocation;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="imalloc-no-sample"><a href="#imalloc-no-sample" class="headerlink" title="imalloc_no_sample"></a>imalloc_no_sample</h4><p>根据alignment和相关属性，对参数进行处理，之后调用函数进行内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">imalloc_no_sample</span><span class="params">(<span class="type">static_opts_t</span> *sopts, <span class="type">dynamic_opts_t</span> *dopts, <span class="type">tsd_t</span> *tsd,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, <span class="type">size_t</span> usize, <span class="type">szind_t</span> ind)</span> &#123;</span><br><span class="line">	<span class="type">tcache_t</span> *tcache;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill in the tcache. */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC) &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(!sopts-&gt;slow)) &#123;</span><br><span class="line">			<span class="comment">/* Getting tcache ptr unconditionally. */</span></span><br><span class="line">			tcache = tsd_tcachep_get(tsd);</span><br><span class="line">			assert(tcache == tcache_get(tsd));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 第一次为slow path，在这里得到tcache */</span></span><br><span class="line">			tcache = tcache_get(tsd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dopts-&gt;tcache_ind == TCACHE_IND_NONE) &#123;</span><br><span class="line">		tcache = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tcache = tcaches_get(tsd, dopts-&gt;tcache_ind);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill in the arena. */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 考虑到自动arena管理，将arena置空，后续从tsd获取 */</span></span><br><span class="line">		arena = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arena = arena_get(tsd_tsdn(tsd), dopts-&gt;arena_ind, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dopts-&gt;alignment != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/* 未对齐 */</span></span><br><span class="line">		<span class="keyword">return</span> ipalloct(tsd_tsdn(tsd), usize, dopts-&gt;alignment,</span><br><span class="line">		    dopts-&gt;zero, tcache, arena);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 这里分配内存 */</span></span><br><span class="line">	<span class="keyword">return</span> iallocztm(tsd_tsdn(tsd), size, ind, dopts-&gt;zero, tcache, <span class="literal">false</span>,</span><br><span class="line">	    arena, sopts-&gt;slow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 之后经过iallocztm-&gt;arena_malloc，根据当前size，决定从tcache的分配，或从arena的extents分配 */</span></span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">szind_t</span> ind, <span class="type">bool</span> zero,</span></span><br><span class="line"><span class="params">    <span class="type">tcache_t</span> *tcache, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || tcache == <span class="literal">NULL</span>);</span><br><span class="line">	assert(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tcache可用，若分配的size满足tcache要求，则从tcache的bins中获取分配的内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tcache != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(size &lt;= SMALL_MAXCLASS)) &#123;</span><br><span class="line">			<span class="comment">/* tcache分配小内存 */</span></span><br><span class="line">			<span class="keyword">return</span> tcache_alloc_small(tsdn_tsd(tsdn), arena,</span><br><span class="line">			    tcache, size, ind, zero, slow_path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (likely(size &lt;= tcache_maxclass)) &#123;</span><br><span class="line">			<span class="comment">/* tcache分配大内存 */</span></span><br><span class="line">			<span class="keyword">return</span> tcache_alloc_large(tsdn_tsd(tsdn), arena,</span><br><span class="line">			    tcache, size, ind, zero, slow_path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* (size &gt; tcache_maxclass) case falls through. */</span></span><br><span class="line">		assert(size &gt; tcache_maxclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 自动初始化的size大小为72704，大于tcache_maxclass，所以不能从tcache</span></span><br><span class="line"><span class="comment">	中分配得到内存，只能在arena中尝试分配 */</span></span><br><span class="line">	<span class="keyword">return</span> arena_malloc_hard(tsdn, arena, size, ind, zero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">szind_t</span> ind,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> zero)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || arena != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!tsdn_null(tsdn))) &#123;</span><br><span class="line">		<span class="comment">/* 前面手动将arena置空，这里根据当前tsd，从arenas数组中得到了arena */</span></span><br><span class="line">		arena = arena_choose(tsdn_tsd(tsdn), arena);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 无法从tcache分配且分配小内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(size &lt;= SMALL_MAXCLASS)) &#123;</span><br><span class="line">		<span class="keyword">return</span> arena_malloc_small(tsdn, arena, ind, zero);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配大内存 */</span></span><br><span class="line">	<span class="keyword">return</span> large_malloc(tsdn, arena, sz_index2size(ind), zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配<strong>小内存</strong>时：<br>虽然前面提起我们是属于<code>large_class</code>，但为了节省篇幅在这里介绍下分配小内存的情况</li>
</ul>
<p>首先，如果是tcache可用的情况下，会尝试从tcache的bins中分配</p>
<p>tcache分配小内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    UNUSED <span class="type">size_t</span> size, <span class="type">szind_t</span> binind, <span class="type">bool</span> zero, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">cache_bin_t</span> *bin;</span><br><span class="line">	<span class="type">bool</span> tcache_success;</span><br><span class="line">	<span class="type">size_t</span> usize <span class="title function_">JEMALLOC_CC_SILENCE_INIT</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">	assert(binind &lt; NBINS);</span><br><span class="line">	<span class="comment">/* 根据binind从tcache-&gt;bins_small数组得到bin */</span></span><br><span class="line">	bin = tcache_small_bin_get(tcache, binind);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 若当前bin中缓存的对象数量不为0，则将剩余空间分配给ret，此时ret = *(bin-&gt;avail - bin-&gt;ncached) </span></span><br><span class="line"><span class="comment">	由于一开始缓存对象为空，所以ret == NULL</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ret = cache_bin_alloc_easy(bin, &amp;tcache_success);</span><br><span class="line">	assert(tcache_success == (ret != <span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tcache_success)) &#123;</span><br><span class="line">		<span class="comment">/* 未能从tcache分配内存，即bin中缓存对象为空 */</span></span><br><span class="line">		<span class="type">bool</span> tcache_hard_success;</span><br><span class="line">		arena = arena_choose(tsd, arena);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 通过hard方法尝试分配内存 */</span></span><br><span class="line">		ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,</span><br><span class="line">		    bin, binind, &amp;tcache_hard_success);</span><br><span class="line">		<span class="keyword">if</span> (tcache_hard_success == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过<code>tcache_alloc_small_hard</code>-&gt;<code>arena_tcache_fill_small</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">cache_bin_t</span> *tbin, <span class="type">szind_t</span> binind, <span class="type">bool</span> *tcache_success)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	assert(tcache-&gt;arena != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 调用此方法用来填充tcache bin */</span></span><br><span class="line">	arena_tcache_fill_small(tsdn, arena, tcache, tbin, binind,</span><br><span class="line">	    config_prof ? tcache-&gt;prof_accumbytes : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (config_prof) &#123;</span><br><span class="line">		tcache-&gt;prof_accumbytes = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* tcache bin填充完毕，之后再次尝试从该bin中获取可用内存 */</span></span><br><span class="line">	ret = cache_bin_alloc_easy(tbin, tcache_success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充tcache bin */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_tcache_fill_small</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">cache_bin_t</span> *tbin, <span class="type">szind_t</span> binind, <span class="type">uint64_t</span> prof_accumbytes)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> i, nfill;</span><br><span class="line">	<span class="type">bin_t</span> *bin;</span><br><span class="line"></span><br><span class="line">	assert(tbin-&gt;ncached == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从arena-&gt;bins中获取bin */</span></span><br><span class="line">	bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环中依次填充bin */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, nfill = (tcache_bin_info[binind].ncached_max &gt;&gt;</span><br><span class="line">	    tcache-&gt;lg_fill_div[binind]); i &lt; nfill; i++) &#123;</span><br><span class="line">		<span class="type">extent_t</span> *slab;</span><br><span class="line">		<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 首先尝试从slab中分配 */</span></span><br><span class="line">		<span class="keyword">if</span> ((slab = bin-&gt;slabcur) != <span class="literal">NULL</span> &amp;&amp; extent_nfree_get(slab) &gt;</span><br><span class="line">		    <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* slab不为空且剩余容量大于0，可以从slab的region中分配，后文介绍 */</span></span><br><span class="line">			ptr = arena_slab_reg_alloc(slab, &amp;bin_infos[binind]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 无法从slab中分配，后文介绍 */</span></span><br><span class="line">			ptr = arena_bin_malloc_hard(tsdn, arena, bin, binind);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">/* OOM异常，将之前分配的内存移出 */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				memmove(tbin-&gt;avail - i, tbin-&gt;avail - nfill,</span><br><span class="line">				    i * <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Insert such that low regions get used first. */</span></span><br><span class="line">		*(tbin-&gt;avail - nfill + i) = ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_mutex_unlock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	tbin-&gt;ncached = i;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从slab的region中分配 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_slab_reg_alloc</span><span class="params">(<span class="type">extent_t</span> *slab, <span class="type">const</span> <span class="type">bin_info_t</span> *bin_info)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">arena_slab_data_t</span> *slab_data = extent_slab_data_get(slab);</span><br><span class="line">	<span class="type">size_t</span> regind;</span><br><span class="line"></span><br><span class="line">	assert(extent_nfree_get(slab) &gt; <span class="number">0</span>);</span><br><span class="line">	assert(!bitmap_full(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 得到region index*/</span> </span><br><span class="line">	regind = bitmap_sfu(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 从slab分配内存 */</span></span><br><span class="line">	ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)extent_addr_get(slab) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_size * regind));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 更新slab内存容量 */</span></span><br><span class="line">	extent_nfree_dec(slab);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 走到此分支说明之前的slab无可用空间或bin-&gt;slabcur == NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_bin_malloc_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">bin_t</span> *bin,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind)</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">bin_info_t</span> *bin_info;</span><br><span class="line">	<span class="type">extent_t</span> *slab;</span><br><span class="line"></span><br><span class="line">	bin_info = &amp;bin_infos[binind];</span><br><span class="line">	<span class="keyword">if</span> (!arena_is_auto(arena) &amp;&amp; bin-&gt;slabcur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* TODO：若当前不是自动分配arena，一般不会出现这种情况，通常arena在0到narenas_auto都是属于自动分配，</span></span><br><span class="line"><span class="comment">		手动分配似乎需要自己申请？这里未验证 */</span></span><br><span class="line">		arena_bin_slabs_full_insert(arena, bin, bin-&gt;slabcur);</span><br><span class="line">		bin-&gt;slabcur = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 首先获取一个未满的slab */</span></span><br><span class="line">	slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind);</span><br><span class="line">	<span class="keyword">if</span> (bin-&gt;slabcur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 结合前提，说明之前的slab即bin-&gt;slabcur无可用空间，而我们在前面又重新获取了一个未满的slab */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Another thread updated slabcur while this one ran without the</span></span><br><span class="line"><span class="comment">		 * bin lock in arena_bin_nonfull_slab_get().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (extent_nfree_get(bin-&gt;slabcur) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 当前bin的slab仍有可用空间，则从bin的slab中分配，我们此时不会走到这个分支 */</span></span><br><span class="line">			<span class="type">void</span> *ret = arena_slab_reg_alloc(bin-&gt;slabcur,</span><br><span class="line">			    bin_info);</span><br><span class="line">			<span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (extent_nfree_get(slab) == bin_info-&gt;nregs) &#123;</span><br><span class="line">					<span class="comment">/* 未满且空闲区域和bin的regions数量相等，说明之前获得的未满的slab是没有被使用的</span></span><br><span class="line"><span class="comment">					状态，释放该slab */</span></span><br><span class="line">					arena_dalloc_bin_slab(tsdn, arena, slab,</span><br><span class="line">					    bin);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/* 更新bin-&gt;slabcur指针，调整bin-&gt;slabcur指向 oldest non-full slab */</span></span><br><span class="line">					arena_bin_lower_slab(tsdn, arena, slab,</span><br><span class="line">					    bin);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 走到这里说明bin-&gt;slabcur已满，将bin-&gt;slabcur插入full slab */</span></span><br><span class="line">		arena_bin_slabs_full_insert(arena, bin, bin-&gt;slabcur);</span><br><span class="line">		bin-&gt;slabcur = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 当前没有未满的slab */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 修改bin-&gt;slabcur指向未满的slab */</span></span><br><span class="line">	bin-&gt;slabcur = slab;</span><br><span class="line"></span><br><span class="line">	assert(extent_nfree_get(bin-&gt;slabcur) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试从新的slab中分配一个region区域并返回 */</span></span><br><span class="line">	<span class="keyword">return</span> arena_slab_reg_alloc(slab, bin_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，从tcache分配小内存完成。其主要逻辑是先从tcache的bins_small中尝试获取一个slab，如果可以从该<br>slab中分配，则返回；若当前tcache没有缓存的slab，则从arena的bin中获取bin，并填充该tcache，之后再尝试<br>从tcache中获取。</p>
<p>接下来是从<strong>tcache分配大内存</strong>：</p>
<p>tcache large bins如缓存对象为空，一次仅分配一块大内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_large</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind, <span class="type">bool</span> zero, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">cache_bin_t</span> *bin;</span><br><span class="line">	<span class="type">bool</span> tcache_success;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 前半部分和从tcache 分配small bins逻辑一致 */</span></span><br><span class="line">	assert(binind &gt;= NBINS &amp;&amp;binind &lt; nhbins);</span><br><span class="line">	bin = tcache_large_bin_get(tcache, binind);</span><br><span class="line">	ret = cache_bin_alloc_easy(bin, &amp;tcache_success);</span><br><span class="line">	assert(tcache_success == (ret != <span class="literal">NULL</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tcache_success)) &#123;</span><br><span class="line">		<span class="comment">/* 分配large bins失败 */</span></span><br><span class="line">		arena = arena_choose(tsd, arena);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 和分配small bins不同的是，分配large bins如果失败，则从arena的extent中分配，</span></span><br><span class="line"><span class="comment">		并且由于代价昂贵，并不会填充tcache large bins，实际的填充行为由gc时执行*/</span></span><br><span class="line">		ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">	tcache_event(tsd, tcache);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>若tcache不可用，且要求分配小内存时(这里的小内存比tcache的小内存要大，即小于等于SMALL_MAXCLASS时)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_small</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">szind_t</span> binind, <span class="type">bool</span> zero)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">bin_t</span> *bin;</span><br><span class="line">	<span class="type">size_t</span> usize;</span><br><span class="line">	<span class="type">extent_t</span> *slab;</span><br><span class="line"></span><br><span class="line">	assert(binind &lt; NBINS);</span><br><span class="line">	bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">	usize = sz_index2size(binind);</span><br><span class="line"></span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> ((slab = bin-&gt;slabcur) != <span class="literal">NULL</span> &amp;&amp; extent_nfree_get(slab) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 尝试从bin的slab中分配内存 */</span></span><br><span class="line">		ret = arena_slab_reg_alloc(slab, &amp;bin_infos[binind]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 前文已分析过此方法，这里不再赘述 */</span></span><br><span class="line">		ret = arena_bin_malloc_hard(tsdn, arena, bin, binind);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>分配<strong>大内存</strong>时：<br>通过<code>arena_extent_alloc_large</code>，从三种<code>extents</code>中得到<code>extent</code>，并从中分配内存，<code>arena_extent_alloc_large</code>函数已<br>在前面分析过，这里不再提及，还是以从extents_retained得到extent为例介绍下之后的情况：</li>
</ul>
<p>已知<code>arena_extent_alloc_large</code>调用了<code>extent_alloc_wrapper</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_alloc_wrapper</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena,</span></span><br><span class="line"><span class="params">    <span class="type">extent_hooks_t</span> **r_extent_hooks, <span class="type">void</span> *new_addr, <span class="type">size_t</span> size, <span class="type">size_t</span> pad,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> slab, <span class="type">szind_t</span> szind, <span class="type">bool</span> *zero, <span class="type">bool</span> *commit)</span> &#123;</span><br><span class="line">	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),</span><br><span class="line">	    WITNESS_RANK_CORE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	extent_hooks_assure_initialized(arena, r_extent_hooks);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 一般情况下，都可以从这个函数获得extent，内部是通过mmap获取的内存 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    new_addr, size, pad, alignment, slab, szind, zero, commit);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opt_retain &amp;&amp; new_addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* mmap没能获取到内存，尝试使用sbrk获取 */</span></span><br><span class="line">		extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,</span><br><span class="line">		    new_addr, size, pad, alignment, slab, szind, zero, commit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(extent == <span class="literal">NULL</span> || extent_dumpable_get(extent));</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取extent的函数，如果extent剩余空间不足，则会尝试通过mmap再次申请内存并放入extents */</span></span><br><span class="line"><span class="type">static</span> <span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_alloc_retained</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena,</span></span><br><span class="line"><span class="params">    <span class="type">extent_hooks_t</span> **r_extent_hooks, <span class="type">void</span> *new_addr, <span class="type">size_t</span> size, <span class="type">size_t</span> pad,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> slab, <span class="type">szind_t</span> szind, <span class="type">bool</span> *zero, <span class="type">bool</span> *commit)</span> &#123;</span><br><span class="line">	assert(size != <span class="number">0</span>);</span><br><span class="line">	assert(alignment != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 首先尝试从现有的extent中分割一部分内存用于当前的内存分配，如果extent != NULL，则成功分割出了内存 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extent_recycle(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    &amp;arena-&gt;extents_retained, new_addr, size, pad, alignment, slab,</span><br><span class="line">	    szind, zero, commit, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (extent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		malloc_mutex_unlock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line">		<span class="keyword">if</span> (config_prof) &#123;</span><br><span class="line">			extent_gdump_add(tsdn, extent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt_retain &amp;&amp; new_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 无法复用现有extent，尝试通过mmap分配内存 */</span></span><br><span class="line">		extent = extent_grow_retained(tsdn, arena, r_extent_hooks, size,</span><br><span class="line">		    pad, alignment, slab, szind, zero, commit);</span><br><span class="line">		<span class="comment">/* extent_grow_retained() always releases extent_grow_mtx. */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		malloc_mutex_unlock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_mutex_assert_not_owner(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="free过程简要分析"><a href="#free过程简要分析" class="headerlink" title="free过程简要分析"></a>free过程简要分析</h2><h3 id="free-function"><a href="#free-function" class="headerlink" title="free function"></a>free function</h3><p><code>free</code>函数的释放内存逻辑仍基于分配的size，<code>arena_dalloc</code>是用于释放内存的主方法。</p>
<p>实际由于所有的内存都是通过arena的extent去管理的，所以实际的内存释放仍要依赖arena管理，无论是<br>tcache中的slab或bin还是arena中的extent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">ifree</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">void</span> *ptr, <span class="type">tcache_t</span> *tcache, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="type">alloc_ctx_t</span> alloc_ctx;</span><br><span class="line">	<span class="type">rtree_ctx_t</span> *rtree_ctx = tsd_rtree_ctx(tsd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从extents_rtree查找szind和slab，并填充进alloc_ctx */</span></span><br><span class="line">	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,</span><br><span class="line">	    (<span class="type">uintptr_t</span>)ptr, <span class="literal">true</span>, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);</span><br><span class="line">	assert(alloc_ctx.szind != NSIZES);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (likely(!slow_path)) &#123;</span><br><span class="line">		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, <span class="literal">false</span>,</span><br><span class="line">		    <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, <span class="literal">false</span>,</span><br><span class="line">		    <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>idalloctm</code>-&gt;<code>arena_dalloc</code>:<br>值得注意的是，tcache的gc不一定会立刻gc，而是尝试将之前gc的对象复用，并增加一个ncached计数，<br>方便下次分配时直接取用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">void</span> *ptr, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">alloc_ctx_t</span> *alloc_ctx, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || tcache == <span class="literal">NULL</span>);</span><br><span class="line">	assert(ptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcache == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/* tcache是从tsd获取的应当不会为空，这里没有验证过什么情况下tcache可能为空 */</span></span><br><span class="line">		arena_dalloc_no_tcache(tsdn, ptr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">szind_t</span> szind;</span><br><span class="line">	<span class="type">bool</span> slab;</span><br><span class="line">	<span class="type">rtree_ctx_t</span> *rtree_ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取szind和slab */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		szind = alloc_ctx-&gt;szind;</span><br><span class="line">		slab = alloc_ctx-&gt;slab;</span><br><span class="line">		assert(szind != NSIZES);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));</span><br><span class="line">		rtree_szind_slab_read(tsdn, &amp;extents_rtree, rtree_ctx,</span><br><span class="line">		    (<span class="type">uintptr_t</span>)ptr, <span class="literal">true</span>, &amp;szind, &amp;slab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(slab)) &#123;</span><br><span class="line">		<span class="comment">/* slab不为空 */</span></span><br><span class="line">		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,</span><br><span class="line">		    slow_path);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* slab为空 */</span></span><br><span class="line">		<span class="keyword">if</span> (szind &lt; nhbins) &#123;</span><br><span class="line">			<span class="comment">/* 可释放到tcache-&gt; large bins*/</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (config_prof &amp;&amp; unlikely(szind &lt; NBINS)) &#123;</span><br><span class="line">				<span class="comment">/* 开启了监测选项 */</span></span><br><span class="line">				arena_dalloc_promoted(tsdn, ptr, tcache,</span><br><span class="line">				    slow_path);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* 从tcache释放大内存 */</span></span><br><span class="line">				tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr,</span><br><span class="line">				    szind, slow_path);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 内存很大，需要通过large_dalloc进行处理 */</span></span><br><span class="line">			<span class="type">extent_t</span> *extent = iealloc(tsdn, ptr);</span><br><span class="line">			large_dalloc(tsdn, extent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续不再针对每个情形详细分析gc，其本质大致相同：如果是通过tcache分配的内存，则将该内存归还，更新<br>ncached计数，调整其指针位置，后续从tcache请求内存时会将该内存分配出去，达到复用的效果；当tcache的bin缓存<br>达到存储上限时也会调用gc，但仍不会实际释放内存，其内存的释放依赖arena的extent。<br>arena的extent在gc时同样不会实际释放内存，并尝试将要释放的extent放入extents_dirty，若一段时间未使用则继续放入<br>extents_muzzy，最后通过arena decay释放</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>jemalloc作为内存分配器，在多方面对glibc allocator进行了优化，包括内存碎片的减少和竞态条件的优化，本文<br>详细分析了其分配内存和gc的过程，了解了buddy 算法和slab算法，加深了对于内存池、内存分配等内容的理解。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="keepalived源码分析">
                  <i class="fa fa-angle-left"></i> keepalived源码分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/11/keepalived-vrrp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="keepalived-vrrp源码分析">
                  keepalived-vrrp源码分析 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Aaron Zhao</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">21k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:15</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
