<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zy-aaron.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="赵耀的博客">
<meta property="og:url" content="https://zy-aaron.github.io/archives/index.html">
<meta property="og:site_name" content="赵耀的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Aaron Zhao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zy-aaron.github.io/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>赵耀的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">赵耀的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aaron Zhao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1946697015@qq.com" title="E-Mail → mailto:1946697015@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2024/06/11/keepalived-vrrp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/11/keepalived-vrrp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">keepalived-vrrp源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-11 14:35:16" itemprop="dateCreated datePublished" datetime="2024-06-11T14:35:16+08:00">2024-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 14:36:42" itemprop="dateModified" datetime="2024-09-01T14:36:42+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/keepalived/" itemprop="url" rel="index"><span itemprop="name">keepalived</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>版本：2.2.8 -&gt; [c3257e94e4] commit</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>建议先阅读前文<code>keepalived-source-analysis.md</code>和RFC 3768。<br>从代码注释来看，keepalived是遵循RFC 2338实现的vrrp，因此新版rfc内的规定有一些可能没有实现，比如当设备网卡本身拥有漂移ip时，RFC 3768要求此时应当让该设备的优先级为255，而keepalived并没有实现该功能。</p>
<h2 id="调用流程分析"><a href="#调用流程分析" class="headerlink" title="调用流程分析"></a>调用流程分析</h2><ol>
<li><code>start_vrrp_child</code>为vrrp主函数，其内部创建了vrrp子进程，并由该子进程处理所有的vrrp事件</li>
<li><code>start_vrrp_child-&gt;start_vrrp</code>主要负责如下内容：<br> 2.1 配置文件读取<br> 2.2 ipvs模块加载<br> 2.3 vrrp_dispatcher的初始化，dispatcher负责处理vrrp报文的读取与发送<br> 2.4 vrrp实例、组的初始化、vrrp报文的组装<br> 2.5 免费arp的初始化等</li>
<li><code>vrrp_dispatcher_init</code>内为每个vrrp实例初始化了两个socket，fd_in和fd_out分别用来接收和发送vrrp报文；同时注册了vrrp工作线程<code>vrrp_read_dispatcher_thread</code></li>
<li><code>vrrp_read_dispatcher_thread</code>根据<strong>是否超时</strong>及当前vrrp实例状态处理vrrp报文的发送与接收</li>
<li>vrrp子进程通过epoll监控是否有可读事件发生，若有则会调用相应回调函数，完成vrrp状态的切换和vrrp报文的发送或接收</li>
</ol>
<h2 id="vrrp状态机"><a href="#vrrp状态机" class="headerlink" title="vrrp状态机"></a>vrrp状态机</h2><blockquote>
<p>以下示意图来自[RFC3768.6.3]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                   +---------------+</span><br><span class="line">        +---------&gt;|               |&lt;-------------+</span><br><span class="line">        |          |  Initialize   |              |</span><br><span class="line">        |   +------|               |----------+   |</span><br><span class="line">        |   |      +---------------+          |   |</span><br><span class="line">        |   |                                 |   |</span><br><span class="line">        |   V                                 V   |</span><br><span class="line">+---------------+                       +---------------+</span><br><span class="line">|               |----------------------&gt;|               |</span><br><span class="line">|    Master     |                       |    Backup     |</span><br><span class="line">|               |&lt;----------------------|               |</span><br><span class="line">+---------------+                       +---------------+</span><br></pre></td></tr></table></figure>

<p>keepalived使用<code>vrrp-&gt;wantstate</code>来表示vrrp即将转变的状态，<code>vrrp-&gt;state</code>则表示当前状态；此外，keepalived除了上述三种状态外，又自定义了<code>VRRP_STATE_FAULT</code>状态和内部的状态转换矩阵，但从代码上看<code>VRRP_STATE_FAULT</code>状态只与一些notify脚本和vrrp组有关，因此对于此状态本文不作讨论。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>下面主要从函数层面介绍一下keepalived对上述状态机的实现逻辑：</p>
<ol start="0">
<li>配置文件内的state仅影响<code>vrrp-&gt;wantstate</code>，若未配置则<code>vrrp-&gt;wantstate</code>为backup状态</li>
<li><code>vrrp_complete_init-&gt;vrrp_complete_instance</code>会初始化vrrp实例的状态（<code>vrrp-&gt;state</code>）为<code>VRRP_STATE_INIT</code>，即图中的<code>Initialize</code>状态</li>
<li><code>vrrp_init_state</code>中，如果配置的优先级为255且当前wantstate为master，则<code>vrrp-&gt;state</code>由<code>Initialize</code>转为<code>Master</code>（这里keepalived实现的方式是先设置其状态为backup，之后设置超时时间为1us，这会很快的触发超时回调并将状态切换为master状态）；其他一律先转为<code>Backup</code>状态</li>
<li>若当前vrrp实例状态为<code>Backup</code>且触发超时回调，其状态会通过<code>vrrp_goto_master</code>转为<code>Master</code>，并发送vrrp报文</li>
<li>若vrrp实例状态为<code>Master</code>且其他设备满足了抢占的条件，则当前设备的状态会通过<code>vrrp_state_master_rx</code>转为<code>Backup</code></li>
<li>keepalived没有实现从<code>Master-&gt;Initialize</code>或从<code>Backup-&gt;Initialize</code>的转换</li>
</ol>
<h3 id="转换逻辑总结"><a href="#转换逻辑总结" class="headerlink" title="转换逻辑总结"></a>转换逻辑总结</h3><ol>
<li><code>Initialize</code>状态：vrrp实例初始化时会进入该状态，之后会判断设备的优先级，若优先级为255则直接进入<code>Master</code>状态，否则会先切换至<code>Backup</code>状态</li>
<li><code>Master</code>状态：处于该状态的设备会做如下工作：<br> 2.1 定时发送vrrp报文<br> 2.2 响应虚拟ip的arp请求<br> 2.3 当收到优先级更高的vrrp报文时，退出<code>Master</code>状态，成为<code>Backup</code><br> 2.4 当收到优先级相同的vrrp报文且本地ip小于报文内的源ip时，退出<code>Master</code>状态，成为<code>Backup</code></li>
<li><code>Backup</code>状态：处于该状态的设备会做如下工作：<br> 3.1 接收<code>Master</code>设备发送的vrrp报文<br> 3.2 不响应虚拟ip的arp请求<br> 3.3 若收到优先级更低的vrrp报文，默认立刻成为<code>Master</code>；若配置了不抢占或抢占延迟则另做处理<br> 3.4 若超过一定时间（Master Down Interval）未收到vrrp报文，则成为<code>Master</code></li>
</ol>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="vrrp-complete-init"><a href="#vrrp-complete-init" class="headerlink" title="vrrp_complete_init"></a>vrrp_complete_init</h3><p><code>vrrp_complete_init</code>用于完成vrrp初始化，包括其内部状态、优先级、源ip等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">vrrp_complete_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vrrp_t</span> *vrrp, *old_vrrp;</span><br><span class="line">	<span class="type">vrrp_sgroup_t</span> *sgroup, *sgroup_tmp;</span><br><span class="line">	<span class="type">size_t</span> max_mtu_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> have_master, have_backup;</span><br><span class="line">	<span class="type">vrrp_script_t</span> *scr, *scr_tmp;</span><br><span class="line">	<span class="type">unsigned</span> quickest_takeover;</span><br><span class="line">	<span class="type">unsigned</span> vrrp_timeout_min = UINT_MAX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查vrrp实例配置合法 */</span></span><br><span class="line">	list_for_each_entry(vrrp, &amp;vrrp_data-&gt;vrrp, e_list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!chk_min_cfg(vrrp))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(vrrp, &amp;vrrp_data-&gt;vrrp, e_list) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 初始化vrrp实例，设置状态和优先级等信息，组装vrrp头和ip头 */</span></span><br><span class="line">		<span class="keyword">if</span> (!vrrp_complete_instance(vrrp))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;ifp &amp;&amp; vrrp-&gt;ifp-&gt;mtu &gt; max_mtu_len)</span><br><span class="line">			max_mtu_len = vrrp-&gt;ifp-&gt;mtu;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 之前记录了其他vrrp实例的最高优先级 */</span></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;highest_other_priority) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* quickest_takeover为backup设备接管master的超时时间，同Master_Down_Interval，</span></span><br><span class="line"><span class="comment">			这里将此时间保存到了vrrp_timeout_min */</span></span><br><span class="line">			quickest_takeover =</span><br><span class="line">			  vrrp-&gt;adver_int * <span class="number">2</span> +</span><br><span class="line">			     (vrrp-&gt;version == VRRP_VERSION_2</span><br><span class="line">			         ? (<span class="number">256U</span> - vrrp-&gt;highest_other_priority) * <span class="number">1000000</span> / <span class="number">256</span></span><br><span class="line">			         : (<span class="number">256U</span> - vrrp-&gt;highest_other_priority) * vrrp-&gt;adver_int / <span class="number">256</span>);</span><br><span class="line">			<span class="keyword">if</span> (quickest_takeover &lt; vrrp_timeout_min)</span><br><span class="line">				vrrp_timeout_min = quickest_takeover;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册vrrp超时处理函数，vrrp_thread_timeout_handler用于将超时的master转为backup */</span></span><br><span class="line">	<span class="keyword">if</span> (vrrp_timeout_min != UINT_MAX)</span><br><span class="line">		register_thread_timeout_handler(vrrp_thread_timeout_handler, vrrp_timeout_min);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保无vrid冲突，即需要保证vrrp实例中vrid、interface、协议族、多播地址至少有一个不同，</span></span><br><span class="line"><span class="comment">	O(n^2)的算法，n为vrrp实例数 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_vrid_conflicts())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清理之前遗留的ip地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (!reload)</span><br><span class="line">		remove_residual_vips();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置发送vrrp报文的源ip */</span></span><br><span class="line">	set_vrrp_src_addr();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reload) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 重载配置后，恢复之前的vrrp状态 */</span></span><br><span class="line">		list_for_each_entry(old_vrrp, &amp;old_vrrp_data-&gt;vrrp, e_list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (old_vrrp-&gt;state == VRRP_STATE_FAULT)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			vrrp = vrrp_exist(old_vrrp, &amp;vrrp_data-&gt;vrrp);</span><br><span class="line">			<span class="keyword">if</span> (vrrp) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_FAULT || vrrp-&gt;num_script_init)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">				vrrp-&gt;state = old_vrrp-&gt;state;</span><br><span class="line">				vrrp-&gt;wantstate = old_vrrp-&gt;state;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WITH_LVS_</span></span><br><span class="line">	<span class="comment">/* lvs会话同步相关 */</span></span><br><span class="line">	<span class="keyword">if</span> (global_data-&gt;lvs_syncd.vrrp_name) &#123;</span><br><span class="line">		list_for_each_entry(vrrp, &amp;vrrp_data-&gt;vrrp, e_list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(global_data-&gt;lvs_syncd.vrrp_name, vrrp-&gt;iname)) &#123;</span><br><span class="line">				<span class="comment">/* 关联vrrp实例 */</span></span><br><span class="line">				global_data-&gt;lvs_syncd.vrrp = vrrp;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置syncid */</span></span><br><span class="line">		<span class="keyword">if</span> (!global_data-&gt;lvs_syncd.vrrp) &#123;</span><br><span class="line">			report_config_error(CONFIG_GENERAL_ERROR, <span class="string">&quot;Unable to find vrrp instance %s&quot;</span></span><br><span class="line">								  <span class="string">&quot; for lvs_syncd - clearing lvs_syncd config&quot;</span></span><br><span class="line">								, global_data-&gt;lvs_syncd.vrrp_name);</span><br><span class="line">			FREE_CONST_PTR(global_data-&gt;lvs_syncd.ifname);</span><br><span class="line">			global_data-&gt;lvs_syncd.ifname = <span class="literal">NULL</span>;</span><br><span class="line">			global_data-&gt;lvs_syncd.syncid = PARAMETER_UNSET;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (global_data-&gt;lvs_syncd.syncid == PARAMETER_UNSET) &#123;</span><br><span class="line">			global_data-&gt;lvs_syncd.syncid = global_data-&gt;lvs_syncd.vrrp-&gt;vrid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FREE_CONST_PTR(global_data-&gt;lvs_syncd.vrrp_name);</span><br><span class="line">		global_data-&gt;lvs_syncd.vrrp_name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (global_data-&gt;lvs_syncd.syncid == PARAMETER_UNSET)</span><br><span class="line">		global_data-&gt;lvs_syncd.syncid = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配vrrp buffer，默认1500字节 */</span></span><br><span class="line">	alloc_vrrp_buffer(max_mtu_len ? max_mtu_len : DEFAULT_MTU);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-dispatcher-init"><a href="#vrrp-dispatcher-init" class="headerlink" title="vrrp_dispatcher_init"></a>vrrp_dispatcher_init</h3><p><code>vrrp_dispatcher_init</code>用于初始化每个vrrp实例的套接字，并注册相关回调</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_dispatcher_init</span><span class="params">(__attribute__((unused)) <span class="type">thread_ref_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 为每个vrrp创建并初始化一个sock结构，并插入vrrp_socket_pool内 */</span></span><br><span class="line">	vrrp_create_sockpool(&amp;vrrp_data-&gt;vrrp_socket_pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对上述创建的sock，调用socket函数打开其fd_in和fd_out */</span></span><br><span class="line">	vrrp_open_sockpool(&amp;vrrp_data-&gt;vrrp_socket_pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将vrrp和sock结构关联起来 */</span></span><br><span class="line">	vrrp_set_fds(&amp;vrrp_data-&gt;vrrp_socket_pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册回调 */</span></span><br><span class="line">	vrrp_register_workers(&amp;vrrp_data-&gt;vrrp_socket_pool);</span><br><span class="line"></span><br><span class="line">	vrrp_initialised = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置reload = 0 */</span></span><br><span class="line">	UNSET_RELOAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="vrrp-open-sockpool"><a href="#vrrp-open-sockpool" class="headerlink" title="vrrp_open_sockpool"></a>vrrp_open_sockpool</h3><p>对于<code>vrrp_socket_pool</code>中的每个sock，通过<code>vrrp_open_sockpool-&gt;open_sockpool_socket</code>调用socket函数生成其fd_in和fd_out，拼装原始套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">open_sockpool_socket</span><span class="params">(<span class="type">sock_t</span> *sock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vrrp_t</span> *vrrp;</span><br><span class="line">	<span class="type">sockaddr_t</span> unicast_src;</span><br><span class="line">	<span class="type">const</span> <span class="type">sockaddr_t</span> *unicast_src_p = sock-&gt;unicast_src;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置单播且ipv6 */</span></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;unicast_src &amp;&amp;</span><br><span class="line">	    sock-&gt;unicast_src-&gt;ss_family == AF_INET6 &amp;&amp;</span><br><span class="line">	    IN6_IS_ADDR_LINKLOCAL(&amp;PTR_CAST_CONST(<span class="keyword">struct</span> sockaddr_in6, sock-&gt;unicast_src)-&gt;sin6_addr)) &#123;</span><br><span class="line">		unicast_src = *sock-&gt;unicast_src;</span><br><span class="line">		unicast_src_p = &amp;unicast_src;</span><br><span class="line"></span><br><span class="line">		PTR_CAST(<span class="keyword">struct</span> sockaddr_in6, &amp;unicast_src)-&gt;sin6_scope_id = sock-&gt;ifp-&gt;ifindex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打开fd_in */</span></span><br><span class="line">	sock-&gt;fd_in = open_vrrp_read_socket(sock-&gt;family, sock-&gt;proto, sock-&gt;ifp,</span><br><span class="line">						sock-&gt;mcast_daddr, unicast_src_p, sock-&gt;rx_buf_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;fd_in == <span class="number">-2</span>) &#123;</span><br><span class="line">		<span class="comment">/* 错误处理 */</span></span><br><span class="line">		rb_for_each_entry(vrrp, &amp;sock-&gt;rb_vrid, rb_vrid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vrrp-&gt;state != VRRP_STATE_FAULT)</span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;(%s): entering FAULT state (src address not configured)&quot;</span>, vrrp-&gt;iname);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 标记其状态为fault */</span></span><br><span class="line">			down_instance(vrrp);</span><br><span class="line">			<span class="keyword">if</span> (vrrp-&gt;num_script_if_fault == <span class="number">1</span>)</span><br><span class="line">				send_instance_notifies(vrrp);</span><br><span class="line">		&#125;</span><br><span class="line">		sock-&gt;fd_in = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;fd_in == <span class="number">-1</span>)</span><br><span class="line">		sock-&gt;fd_out = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 打开fd_out */</span></span><br><span class="line">		sock-&gt;fd_out = open_vrrp_send_socket(sock-&gt;family, sock-&gt;proto, sock-&gt;ifp,</span><br><span class="line">							unicast_src_p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_vrrp_read_socket</span><span class="params">(<span class="type">sa_family_t</span> family, <span class="type">int</span> proto, <span class="type">const</span> <span class="type">interface_t</span> *ifp,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="type">sockaddr_t</span> *mcast_daddr, <span class="type">const</span> <span class="type">sockaddr_t</span> *unicast_src, <span class="type">int</span> rx_buf_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> val = rx_buf_size;</span><br><span class="line">	<span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(val);</span><br><span class="line">	<span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打开socket */</span></span><br><span class="line">	fd = socket(family, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, proto);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> err = errno;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;cant open raw socket. errno=%d&quot;</span>, err);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置接受buffer大小 */</span></span><br><span class="line">	<span class="keyword">if</span> (rx_buf_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &amp;val, len))</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;vrrp set receive socket buffer size error %d&quot;</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_DECL_IPV6_MULTICAST_ALL</span></span><br><span class="line">	<span class="keyword">if</span> (family == AF_INET)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="comment">/* 设置IP_MULTICAST_ALL为0，这会让此套接字仅接受显式加入的组发送的组播报文，</span></span><br><span class="line"><span class="comment">		例如通过IP_ADD_MEMBERSHIP显示加入某个组 */</span></span><br><span class="line">		if_setsockopt_mcast_all(family, &amp;fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!unicast_src) &#123;</span><br><span class="line">		<span class="comment">/* 通过IP_ADD_MEMBERSHIP设置当前套接字加入组播组 */</span></span><br><span class="line">		if_join_vrrp_group(family, &amp;fd, ifp, mcast_daddr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 绑定组播地址，默认224.0.0.18 */</span></span><br><span class="line">		<span class="keyword">if</span> ((family == AF_INET &amp;&amp; bind(fd, PTR_CAST_CONST(<span class="keyword">struct</span> sockaddr, mcast_daddr), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))) ||</span><br><span class="line">		    (family == AF_INET6 &amp;&amp; bind(fd, PTR_CAST_CONST(<span class="keyword">struct</span> sockaddr, mcast_daddr), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6))))</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;bind for multicast failed %d - %m&quot;</span>, errno);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 绑定单播地址 */</span></span><br><span class="line">		<span class="keyword">if</span> (bind(fd, PTR_CAST_CONST(<span class="keyword">struct</span> sockaddr, unicast_src), unicast_src-&gt;ss_family == AF_INET ? <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in) : <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6))) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;bind unicast_src %s failed %d - %m&quot;</span>, inet_sockaddrtos(unicast_src), errno);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ifp)</span><br><span class="line">		<span class="comment">/* 通过SO_BINDTODEVICE设置绑定网卡 */</span></span><br><span class="line">		if_setsockopt_bindtodevice(&amp;fd, ifp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_vrrp_send_socket</span><span class="params">(<span class="type">sa_family_t</span> family, <span class="type">int</span> proto, <span class="type">const</span> <span class="type">interface_t</span> *ifp, <span class="type">const</span> <span class="type">sockaddr_t</span> *unicast_src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (family != AF_INET &amp;&amp; family != AF_INET6) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;cant open raw socket. unknown family=%d&quot;</span></span><br><span class="line">				    , family);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建socket */</span></span><br><span class="line">	fd = socket(family, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, proto);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;cant open raw socket. errno=%d&quot;</span>, errno);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于发送端socket，设置接收buffer大小为0 */</span></span><br><span class="line">	<span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &amp;val, len))</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;vrrp set send socket buffer size error %d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_DECL_IPV6_MULTICAST_ALL</span></span><br><span class="line">	<span class="keyword">if</span> (family == AF_INET)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="comment">/* 设置IP_MULTICAST_ALL为0，这会让此套接字仅接受显式加入的组发送的组播报文，</span></span><br><span class="line"><span class="comment">		例如通过IP_ADD_MEMBERSHIP显示加入某个组 */</span></span><br><span class="line">		if_setsockopt_mcast_all(family, &amp;fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (family == AF_INET) &#123;</span><br><span class="line">		<span class="comment">/* 设置IP_HDRINCL，表示手动组装ip头 */</span></span><br><span class="line">		if_setsockopt_hdrincl(&amp;fd);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (family == AF_INET6) &#123;</span><br><span class="line">		if_setsockopt_ipv6_checksum(&amp;fd);</span><br><span class="line">		<span class="keyword">if</span> (!unicast_src)</span><br><span class="line">			if_setsockopt_mcast_hops(family, &amp;fd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ifp) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过SO_BINDTODEVICE绑定socket和网卡 */</span></span><br><span class="line">		if_setsockopt_bindtodevice(&amp;fd, ifp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!unicast_src) &#123;</span><br><span class="line">			<span class="comment">/* 通过IP_MULTICAST_IF绑定组播网卡 */</span></span><br><span class="line">			if_setsockopt_mcast_if(family, &amp;fd, ifp);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 通过IP_MULTICAST_LOOP设定发送的组播包会回环到本地 */</span></span><br><span class="line">			if_setsockopt_mcast_loop(family, &amp;fd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 通过IP_TOS设置tos为IPTOS_PREC_INTERNETCONTROL */</span></span><br><span class="line">	if_setsockopt_priority(&amp;fd, family);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过SO_ATTACH_FILTER设置此socket不接收包 */</span></span><br><span class="line">	if_setsockopt_no_receive(&amp;fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-register-workers"><a href="#vrrp-register-workers" class="headerlink" title="vrrp_register_workers"></a>vrrp_register_workers</h3><p>初始化vrrp状态、时间，设置回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_register_workers</span><span class="params">(<span class="type">list_head_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sock_t</span> *sock;</span><br><span class="line">	<span class="type">timeval_t</span> timer;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;timer, <span class="number">0</span>, <span class="keyword">sizeof</span>(timer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化vrrp实例状态 */</span></span><br><span class="line">	vrrp_init_state(&amp;vrrp_data-&gt;vrrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化vrrp实例时间 */</span></span><br><span class="line">	vrrp_init_sands(&amp;vrrp_data-&gt;vrrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册vrrp工作线程 */</span></span><br><span class="line">	list_for_each_entry(sock, l, e_list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sock-&gt;fd_in != <span class="number">-1</span>)</span><br><span class="line">			sock-&gt;thread = thread_add_read_sands(master, vrrp_read_dispatcher_thread,</span><br><span class="line">						       sock, sock-&gt;fd_in, vrrp_compute_timer(sock), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vrrp-init-state"><a href="#vrrp-init-state" class="headerlink" title="vrrp_init_state"></a>vrrp_init_state</h4><p>初始化vrrp实例状态，仅当配置优先级为255时才会成为master，否则会先进入backup状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_init_state</span><span class="params">(<span class="type">list_head_t</span> *l)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vrrp_t</span> *vrrp;</span><br><span class="line">	<span class="type">vrrp_sgroup_t</span> *vgroup;</span><br><span class="line">	<span class="type">bool</span> is_up;</span><br><span class="line">	<span class="type">int</span> new_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新时间 */</span></span><br><span class="line">	set_time_now();</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(vrrp, l, e_list) &#123;</span><br><span class="line">		<span class="type">int</span> vrrp_begin_state = vrrp-&gt;state;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_FAULT)</span><br><span class="line">			vrrp-&gt;wantstate = VRRP_STATE_FAULT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 我们没有设置vrrp组，因此vrrp-&gt;sync为空 */</span></span><br><span class="line">		new_state = vrrp-&gt;sync ? vrrp-&gt;sync-&gt;state : vrrp-&gt;wantstate;</span><br><span class="line"></span><br><span class="line">		is_up = VRRP_ISUP(vrrp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这里的if仅在当前vrrp实例状态为master时才会进入，除非一开始优先级就配置为</span></span><br><span class="line"><span class="comment">		255，否则任何实例都会先进入backup状态，之后才会选出master */</span></span><br><span class="line">		<span class="keyword">if</span> (is_up &amp;&amp;</span><br><span class="line">		    new_state == VRRP_STATE_MAST &amp;&amp;</span><br><span class="line">		    !vrrp-&gt;num_script_init &amp;&amp; (!vrrp-&gt;sync || !vrrp-&gt;sync-&gt;num_member_init) &amp;&amp;</span><br><span class="line">		    (vrrp-&gt;base_priority == VRRP_PRIO_OWNER ||</span><br><span class="line">		     vrrp-&gt;reload_master) &amp;&amp;</span><br><span class="line">		    vrrp-&gt;wantstate == VRRP_STATE_MAST) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WITH_LVS_</span></span><br><span class="line">			<span class="comment">/* 检查是否开启lvs会话同步 */</span></span><br><span class="line">			<span class="keyword">if</span> (global_data-&gt;lvs_syncd.ifname &amp;&amp;</span><br><span class="line">			    global_data-&gt;lvs_syncd.vrrp == vrrp &amp;&amp;</span><br><span class="line">			    !global_data-&gt;lvs_syncd.daemon_set_reload)</span><br><span class="line">				ipvs_syncd_cmd(IPVS_STARTDAEMON,</span><br><span class="line">					       &amp;global_data-&gt;lvs_syncd,</span><br><span class="line">					       vrrp-&gt;state == VRRP_STATE_MAST ? IPVS_MASTER : IPVS_BACKUP,</span><br><span class="line">					       <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">if</span> (!vrrp-&gt;reload_master) &#123;</span><br><span class="line">				<span class="comment">/* 先成为backup，之后将超时时间设置的特别短（1us），从而尽快转为master */</span></span><br><span class="line">				vrrp-&gt;state = VRRP_STATE_BACK;</span><br><span class="line">				vrrp-&gt;ms_down_timer = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 没有vrrp组，因此new_state总是等于vrrp-&gt;wantstate */</span></span><br><span class="line">			<span class="keyword">if</span> (new_state == VRRP_STATE_BACK &amp;&amp; vrrp-&gt;wantstate == VRRP_STATE_MAST) &#123;</span><br><span class="line">				vrrp-&gt;ms_down_timer = vrrp-&gt;master_adver_int + VRRP_TIMER_SKEW_MIN(vrrp);</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				vrrp-&gt;ms_down_timer = VRRP_MS_DOWN_TIMER(vrrp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WITH_LVS_</span></span><br><span class="line">			<span class="comment">/* 检查是否开启lvs会话同步 */</span></span><br><span class="line">			<span class="keyword">if</span> (global_data-&gt;lvs_syncd.ifname &amp;&amp;</span><br><span class="line">			    global_data-&gt;lvs_syncd.vrrp == vrrp &amp;&amp;</span><br><span class="line">			    !global_data-&gt;lvs_syncd.daemon_set_reload)</span><br><span class="line">				ipvs_syncd_cmd(IPVS_STARTDAEMON,</span><br><span class="line">					       &amp;global_data-&gt;lvs_syncd,</span><br><span class="line">					       IPVS_BACKUP,</span><br><span class="line">					       <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* 重置网卡状态，包括移除虚拟路由、虚拟ip等 */</span></span><br><span class="line">			vrrp_restore_interface(vrrp, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (is_up &amp;&amp;</span><br><span class="line">			    new_state != VRRP_STATE_FAULT &amp;&amp;</span><br><span class="line">			    !vrrp-&gt;num_script_init &amp;&amp;</span><br><span class="line">			    (!vrrp-&gt;sync || !vrrp-&gt;sync-&gt;num_member_init)) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 设置为backup状态 */</span></span><br><span class="line">				<span class="keyword">if</span> (vrrp-&gt;state != VRRP_STATE_BACK) &#123;</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;(%s) Entering BACKUP STATE (init)&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">					vrrp-&gt;state = VRRP_STATE_BACK;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (vrrp_begin_state != vrrp-&gt;state)</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;(%s) Entering FAULT STATE (init)&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">				vrrp-&gt;state = VRRP_STATE_FAULT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="vrrp-read-dispatcher-thread"><a href="#vrrp-read-dispatcher-thread" class="headerlink" title="vrrp_read_dispatcher_thread"></a>vrrp_read_dispatcher_thread</h4><p>master和backup会根据此时线程的状态走不同的逻辑。对于一个vrrp实例，其作为master超时时需要发送vrrp报文，其作为backup超时则需要转为master；同样的，若未超时则根据其master或backup的状态也需要处理不同的接收vrrp报文逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_read_dispatcher_thread</span><span class="params">(<span class="type">thread_ref_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sock_t</span> *sock;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">	sock = THREAD_ARG(thread);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 超时，则调用vrrp_dispatcher_read_timeout；否则就调用vrrp_dispatcher_read */</span></span><br><span class="line">	<span class="keyword">if</span> (thread-&gt;type == THREAD_READ_TIMEOUT || sock-&gt;fd_in == <span class="number">-1</span>)</span><br><span class="line">		fd = vrrp_dispatcher_read_timeout(sock);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		fd = vrrp_dispatcher_read(sock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册下一个dispatcher线程 */</span></span><br><span class="line">	<span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">		sock-&gt;thread = thread_add_read_sands(thread-&gt;master, vrrp_read_dispatcher_thread,</span><br><span class="line">						     sock, fd, vrrp_compute_timer(sock), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vrrp-dispatcher-read-timeout"><a href="#vrrp-dispatcher-read-timeout" class="headerlink" title="vrrp_dispatcher_read_timeout"></a>vrrp_dispatcher_read_timeout</h4><p>处理超时事件，若当前为master，则需要发送vrrp保文；若为backup，则需转为master</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">vrrp_dispatcher_read_timeout</span><span class="params">(<span class="type">sock_t</span> *sock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vrrp_t</span> *vrrp;</span><br><span class="line">	<span class="type">int</span> prev_state;</span><br><span class="line"></span><br><span class="line">	set_time_now();</span><br><span class="line"></span><br><span class="line">	rb_for_each_entry_cached(vrrp, &amp;sock-&gt;rb_sands, rb_sands) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;sands.tv_sec == TIMER_DISABLED ||</span><br><span class="line">		    timercmp(&amp;vrrp-&gt;sands, &amp;time_now, &gt;))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		prev_state = vrrp-&gt;state;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_BACK)</span><br><span class="line">			<span class="comment">/* 当前为backup，接收vrrp报文超时，需要转为master */</span></span><br><span class="line">			vrrp_goto_master(vrrp);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_MAST)</span><br><span class="line">			<span class="comment">/* 当前为master，需要继续发送vrrp报文 */</span></span><br><span class="line">			vrrp_state_master_tx(vrrp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新vrrp超时时间 */</span></span><br><span class="line">		vrrp_init_instance_sands(vrrp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock-&gt;fd_in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="vrrp-dispatcher-read"><a href="#vrrp-dispatcher-read" class="headerlink" title="vrrp_dispatcher_read"></a>vrrp_dispatcher_read</h4><p>读事件就绪时未超时，表明当前收到了其他主机发送的vrrp报文，此函数用于处理接收和解析vrrp报文</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">vrrp_dispatcher_read</span><span class="params">(<span class="type">sock_t</span> *sock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">vrrp_t</span> *vrrp;</span><br><span class="line">	<span class="type">rb_node_t</span> *vrrp_node;</span><br><span class="line">	<span class="type">const</span> <span class="type">vrrphdr_t</span> *hd;</span><br><span class="line">	<span class="type">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> prev_state = <span class="number">0</span>;</span><br><span class="line">	<span class="type">sockaddr_t</span> src_addr = &#123; .ss_family = AF_UNSPEC &#125;;</span><br><span class="line">	<span class="type">char</span> control_buf[<span class="number">64</span>] __attribute__((aligned(__alignof__(<span class="keyword">struct</span> cmsghdr))));</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec</span> =</span> &#123; .iov_base = vrrp_buffer, .iov_len = vrrp_buffer_len &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msghdr</span> =</span> &#123; .msg_name = &amp;src_addr, .msg_namelen = <span class="keyword">sizeof</span>(src_addr),</span><br><span class="line">				 .msg_iov = &amp;iovec, .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">				 .msg_control = control_buf, .msg_controllen = <span class="keyword">sizeof</span>(control_buf) &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">	<span class="type">bool</span> expected_cmsg;</span><br><span class="line">	<span class="type">unsigned</span> eintr_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rx_vrid_map[BIT_WORD(<span class="number">256</span> + BIT_PER_LONG - <span class="number">1</span>)] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">bool</span> terminate_receiving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="type">unicast_peer_t</span> *unicast_peer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!terminate_receiving) &#123;</span><br><span class="line">		eintr_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 接收vrrp报文 */</span></span><br><span class="line">		<span class="keyword">while</span> ((len = recvmsg(sock-&gt;fd_in, &amp;msghdr, MSG_TRUNC | MSG_CTRUNC)) == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">		       check_EINTR(errno) &amp;&amp; eintr_count++ &lt; <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 错误处理 */</span></span><br><span class="line">			<span class="keyword">if</span> (!check_EAGAIN(errno))</span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;recvmsg(%d) returned %d (%m)&quot;</span></span><br><span class="line">						    , sock-&gt;fd_in, errno);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;recvmsg(%d) returned data length 0&quot;</span>, sock-&gt;fd_in);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 消息不完整 */</span></span><br><span class="line">		<span class="keyword">if</span> (msghdr.msg_flags &amp; MSG_TRUNC) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;recvmsg(%d) message truncated from %zd to %zu bytes&quot;</span></span><br><span class="line">					    , sock-&gt;fd_in, len, vrrp_buffer_len);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 消息不完整 */</span></span><br><span class="line">		<span class="keyword">if</span> (msghdr.msg_flags &amp; MSG_CTRUNC) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;recvmsg(%d), control message truncated from %zu to %&quot;</span> PRI_MSG_CONTROLLEN <span class="string">&quot; bytes&quot;</span></span><br><span class="line">					    , sock-&gt;fd_in, <span class="keyword">sizeof</span>(control_buf), msghdr.msg_controllen);</span><br><span class="line">			msghdr.msg_controllen = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp_delayed_start_time.tv_sec)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 校验ip头和vrrp头 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(hd = vrrp_get_header(sock-&gt;family, vrrp_buffer, len)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		vrrp_node = rb_find(&amp;hd-&gt;vrid, &amp;sock-&gt;rb_vrid, vrrp_vrid_cmp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 没有找到对应的vrrp实例，忽略当前vrrp报文 */</span></span><br><span class="line">		<span class="keyword">if</span> (!vrrp_node) &#123;</span><br><span class="line">			<span class="keyword">if</span> (global_data-&gt;log_unknown_vrids)</span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;Unknown VRID(%d) received on interface(%s). ignoring...&quot;</span></span><br><span class="line">						    , hd-&gt;vrid, IF_NAME(sock-&gt;ifp));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vrrp = rb_entry(vrrp_node, <span class="type">vrrp_t</span>, rb_vrid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这里用于保证一次对于同一vrid仅处理一个vrrp报文 */</span></span><br><span class="line">		<span class="keyword">if</span> (__test_and_set_bit_array(hd-&gt;vrid, rx_vrid_map))</span><br><span class="line">			terminate_receiving = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_FAULT || vrrp-&gt;state == VRRP_STATE_INIT)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 保存ip头数据 */</span></span><br><span class="line">		vrrp-&gt;pkt_saddr = src_addr;</span><br><span class="line">		vrrp-&gt;rx_ttl_hop_limit = <span class="number">-1</span>;           <span class="comment">/* Default to not received */</span></span><br><span class="line">		<span class="keyword">if</span> (sock-&gt;family == AF_INET) &#123;</span><br><span class="line">			iph = PTR_CAST_CONST(<span class="keyword">struct</span> iphdr, vrrp_buffer);</span><br><span class="line">			vrrp-&gt;multicast_pkt = IN_MULTICAST(htonl(iph-&gt;daddr));</span><br><span class="line">			vrrp-&gt;rx_ttl_hop_limit = iph-&gt;ttl;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			vrrp-&gt;multicast_pkt = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		prev_state = vrrp-&gt;state;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_BACK)</span><br><span class="line">			<span class="comment">/* 当前为backup，检查vrrp报文优先级，若接收到的vrrp优先级为0或</span></span><br><span class="line"><span class="comment">			开启抢占且报文优先级小于自身，则通过调整ms_down_timer尝试转换为master */</span></span><br><span class="line">			vrrp_state_backup(vrrp, hd, vrrp_buffer, len);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vrrp-&gt;state == VRRP_STATE_MAST) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 当前为master，且收到了更高优先级的vrrp保文或同一优先级但ip地址更大的报文，</span></span><br><span class="line"><span class="comment">			则切换当前状态为backup */</span></span><br><span class="line">			<span class="keyword">if</span> (vrrp_state_master_rx(vrrp, hd, vrrp_buffer, len))</span><br><span class="line">				vrrp_state_leave_master(vrrp, <span class="literal">false</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;(%s) In dispatcher_read with state %d&quot;</span></span><br><span class="line">					    , vrrp-&gt;iname, vrrp-&gt;state);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;state != VRRP_STATE_MAST || !vrrp-&gt;lower_prio_no_advert)</span><br><span class="line">			vrrp_init_instance_sands(vrrp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock-&gt;fd_in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-goto-master"><a href="#vrrp-goto-master" class="headerlink" title="vrrp_goto_master"></a>vrrp_goto_master</h3><p><code>vrrp_goto_master</code>将当前vrrp实例的状态转为master</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_goto_master</span><span class="params">(<span class="type">vrrp_t</span> * vrrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 先设置wantstate状态为master */</span></span><br><span class="line">	vrrp-&gt;wantstate = VRRP_STATE_MAST;</span><br><span class="line">	vrrp_state_goto_master(vrrp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_state_goto_master</span><span class="params">(<span class="type">vrrp_t</span> * vrrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* vrrp组相关，这里略过 */</span></span><br><span class="line">	<span class="keyword">if</span> (vrrp-&gt;sync &amp;&amp; !vrrp_sync_can_goto_master(vrrp))</span><br><span class="line">	&#123;</span><br><span class="line">		vrrp-&gt;wantstate = VRRP_STATE_MAST;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更改状态为master，更新超时时间 */</span></span><br><span class="line">	vrrp-&gt;state = VRRP_STATE_MAST;</span><br><span class="line">	vrrp_init_instance_sands(vrrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 发送vrrp报文 */</span></span><br><span class="line">	vrrp_state_master_tx(vrrp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-state-master-tx"><a href="#vrrp-state-master-tx" class="headerlink" title="vrrp_state_master_tx"></a>vrrp_state_master_tx</h3><p>处于master状态的实例通过此方法发送vrrp报文和免费arp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_state_master_tx</span><span class="params">(<span class="type">vrrp_t</span> * vrrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送vrrp报文，effective_priority为vrrp头里面的优先级 */</span></span><br><span class="line">	vrrp_send_adv(vrrp, vrrp-&gt;effective_priority);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!VRRP_VIP_ISSET(vrrp)) &#123;</span><br><span class="line">		<span class="comment">/* vip没有被完全添加上 */</span></span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;(%s) Entering MASTER STATE&quot;</span></span><br><span class="line">				    , vrrp-&gt;iname);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 通过netlink向网卡添加配置的vip、evip、vroutes和vrules，</span></span><br><span class="line"><span class="comment">		并设置了免费arp刷新时间等 */</span></span><br><span class="line">		vrrp_state_become_master(vrrp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置延迟指定时间后发送免费vrp */</span></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;garp_delay)</span><br><span class="line">			thread_add_timer(master, vrrp_gratuitous_arp_thread,</span><br><span class="line">					 vrrp, vrrp-&gt;garp_delay);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 若设置了刷新时间，则发送免费arp并更新arp刷新时间 */</span></span><br><span class="line">		<span class="keyword">if</span> (timerisset(&amp;vrrp-&gt;garp_refresh) &amp;&amp;</span><br><span class="line">		    timercmp(&amp;time_now, &amp;vrrp-&gt;garp_refresh_timer, &gt;)) &#123;</span><br><span class="line">			vrrp_send_link_update(vrrp, vrrp-&gt;garp_refresh_rep);</span><br><span class="line">			vrrp-&gt;garp_refresh_timer = timer_add_now(vrrp-&gt;garp_refresh);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-state-master-rx"><a href="#vrrp-state-master-rx" class="headerlink" title="vrrp_state_master_rx"></a>vrrp_state_master_rx</h3><p><code>vrrp_state_master_rx</code>用于处理master设备收到vrrp保文的情况，返回true表明当前设备<br>需要离开master状态，false则维持master状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">vrrp_state_master_rx</span><span class="params">(<span class="type">vrrp_t</span> * vrrp, <span class="type">const</span> <span class="type">vrrphdr_t</span> *hd, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">ssize_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line">	<span class="type">unsigned</span> master_adver_int;</span><br><span class="line">	<span class="type">int</span> addr_cmp;</span><br><span class="line">	<span class="type">vrrp_t</span> *isync;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 校验收到的包，丢弃无效的包 */</span></span><br><span class="line">	ret = vrrp_check_packet(vrrp, hd, buf, buflen, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret != VRRP_PACKET_OK)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里记录ip地址的比较结果，用于后续处理优先级一样时选择ip地址更大的一方为master */</span></span><br><span class="line">	addr_cmp = vrrp_saddr_cmp(&amp;vrrp-&gt;pkt_saddr, vrrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当收到优先级为0或优先级比自己更高的报文时，先发送一个vrrp保文 */</span></span><br><span class="line">	<span class="keyword">if</span> (hd-&gt;priority == <span class="number">0</span> ||</span><br><span class="line">	    (vrrp-&gt;higher_prio_send_advert &amp;&amp;</span><br><span class="line">	     (hd-&gt;priority &gt; vrrp-&gt;effective_priority ||</span><br><span class="line">	      (hd-&gt;priority == vrrp-&gt;effective_priority &amp;&amp; addr_cmp &gt; <span class="number">0</span>)))) &#123;</span><br><span class="line">		vrrp_send_adv(vrrp, vrrp-&gt;effective_priority);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 收到的vrrp报文优先级为0，维持master状态 */</span></span><br><span class="line">		<span class="keyword">if</span> (hd-&gt;priority == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (__test_bit(LOG_DETAIL_BIT, &amp;debug))</span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;(%s) Master received priority 0 message&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 收到的优先级和自身相等 */</span></span><br><span class="line">	<span class="keyword">if</span> (hd-&gt;priority == vrrp-&gt;effective_priority) &#123;</span><br><span class="line">		<span class="keyword">if</span> (addr_cmp == <span class="number">0</span>)</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;(%s) WARNING - equal priority advert received from remote host with our IP address.&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vrrp-&gt;effective_priority == VRRP_PRIO_OWNER) &#123;</span><br><span class="line">			<span class="comment">/* 如果本身已经配置了优先级为255，又收到了其他优先级为255的报文，</span></span><br><span class="line"><span class="comment">			发生了冲突，这里更改当前保文优先级为254 */</span></span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;(%s) CONFIGURATION ERROR: local instance and a remote instance are both configured as address owner, please fix - reducing local priority&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">			vrrp-&gt;effective_priority = VRRP_PRIO_OWNER - <span class="number">1</span>;</span><br><span class="line">			vrrp-&gt;base_priority = VRRP_PRIO_OWNER - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 收到了更低优先级的报文，或优先级相同但ip地址小于当前发包ip地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (hd-&gt;priority &lt; vrrp-&gt;effective_priority ||</span><br><span class="line">	    (hd-&gt;priority == vrrp-&gt;effective_priority &amp;&amp;</span><br><span class="line">	     addr_cmp &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 根据配置选择发送vrrp报文或免费arp */</span></span><br><span class="line">		<span class="keyword">if</span> (!vrrp-&gt;lower_prio_no_advert)</span><br><span class="line">			vrrp_send_adv(vrrp, vrrp-&gt;effective_priority);</span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;garp_lower_prio_rep) &#123;</span><br><span class="line">			vrrp_send_link_update(vrrp, vrrp-&gt;garp_lower_prio_rep);</span><br><span class="line">			<span class="keyword">if</span> (vrrp-&gt;garp_lower_prio_delay)</span><br><span class="line">				thread_add_timer(master, vrrp_lower_prio_gratuitous_arp_thread,</span><br><span class="line">						 vrrp, vrrp-&gt;garp_lower_prio_delay);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 维持master状态 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 收到了更高优先级的报文，或同一优先级但vrrp报文内ip地址大于当前实例配置的ip */</span></span><br><span class="line">	<span class="keyword">if</span> (hd-&gt;priority &gt; vrrp-&gt;effective_priority ||</span><br><span class="line">	    (hd-&gt;priority == vrrp-&gt;effective_priority &amp;&amp; addr_cmp &gt; <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更改超时时间和状态，尽快触发回调并切换到backup */</span></span><br><span class="line">		vrrp-&gt;ms_down_timer = VRRP_MS_DOWN_TIMER(vrrp);</span><br><span class="line">		vrrp-&gt;master_priority = hd-&gt;priority;</span><br><span class="line">		vrrp-&gt;wantstate = VRRP_STATE_BACK;</span><br><span class="line">		vrrp-&gt;state = VRRP_STATE_BACK;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vrrp-state-backup"><a href="#vrrp-state-backup" class="headerlink" title="vrrp_state_backup"></a>vrrp_state_backup</h3><p>backup状态的设备收到vrrp保文后的处理逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vrrp_state_backup</span><span class="params">(<span class="type">vrrp_t</span> *vrrp, <span class="type">const</span> <span class="type">vrrphdr_t</span> *hd, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">ssize_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> master_adver_int;</span><br><span class="line">	<span class="type">bool</span> check_addr = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">timeval_t</span> new_ms_down_timer;</span><br><span class="line">	<span class="type">bool</span> ignore_advert = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 校验包的合法性 */</span></span><br><span class="line">	<span class="keyword">if</span> (!__test_bit(VRRP_FLAG_SKIP_CHECK_ADV_ADDR, &amp;vrrp-&gt;flags) ||</span><br><span class="line">	    vrrp-&gt;master_saddr.ss_family != vrrp-&gt;pkt_saddr.ss_family)</span><br><span class="line">		check_addr = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;pkt_saddr.ss_family == AF_INET) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PTR_CAST(<span class="keyword">struct</span> sockaddr_in, &amp;vrrp-&gt;pkt_saddr)-&gt;sin_addr.s_addr != PTR_CAST(<span class="keyword">struct</span> sockaddr_in, &amp;vrrp-&gt;master_saddr)-&gt;sin_addr.s_addr)</span><br><span class="line">				check_addr = <span class="literal">true</span> ;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!IN6_ARE_ADDR_EQUAL(&amp;PTR_CAST(<span class="keyword">struct</span> sockaddr_in6, &amp;vrrp-&gt;pkt_saddr)-&gt;sin6_addr, &amp;PTR_CAST(<span class="keyword">struct</span> sockaddr_in6, &amp;vrrp-&gt;master_saddr)-&gt;sin6_addr))</span><br><span class="line">				check_addr = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = vrrp_check_packet(vrrp, hd, buf, buflen, check_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret != VRRP_PACKET_OK)</span><br><span class="line">		ignore_advert = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (hd-&gt;priority == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 收到了优先级为0的报文，更改超时时间，期望尽快触发回调 */</span></span><br><span class="line">		vrrp-&gt;ms_down_timer = VRRP_TIMER_SKEW(vrrp);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__test_bit(VRRP_FLAG_NOPREEMPT, &amp;vrrp-&gt;flags) ||</span><br><span class="line">		   hd-&gt;priority &gt;= vrrp-&gt;effective_priority ||</span><br><span class="line">		   (vrrp-&gt;preempt_delay &amp;&amp;</span><br><span class="line">		    (!vrrp-&gt;preempt_time.tv_sec ||</span><br><span class="line">		     timercmp(&amp;vrrp-&gt;preempt_time, &amp;time_now, &gt;)))) &#123;</span><br><span class="line">		<span class="comment">/* 开启了非抢占或vrrp报文优先级更高 */</span></span><br><span class="line"></span><br><span class="line">		vrrp-&gt;ms_down_timer = VRRP_MS_DOWN_TIMER(vrrp);</span><br><span class="line">		vrrp-&gt;master_saddr = vrrp-&gt;pkt_saddr;</span><br><span class="line">		vrrp-&gt;master_priority = hd-&gt;priority;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vrrp-&gt;preempt_delay) &#123;</span><br><span class="line">			<span class="comment">/* 开启了抢占延迟 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (hd-&gt;priority &gt;= vrrp-&gt;effective_priority) &#123;</span><br><span class="line">				<span class="comment">/* 无需抢占，所以抢占时间不生效 */</span></span><br><span class="line">				<span class="keyword">if</span> (vrrp-&gt;preempt_time.tv_sec) &#123;</span><br><span class="line">					<span class="keyword">if</span> (__test_bit(LOG_DETAIL_BIT, &amp;debug))</span><br><span class="line">						log_message(LOG_INFO,</span><br><span class="line">							<span class="string">&quot;(%s) stop preempt delay&quot;</span>, vrrp-&gt;iname);</span><br><span class="line">					vrrp-&gt;preempt_time.tv_sec = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vrrp-&gt;preempt_time.tv_sec) &#123;</span><br><span class="line">				<span class="comment">/* 更新抢占时间 */</span></span><br><span class="line">				<span class="keyword">if</span> (__test_bit(LOG_DETAIL_BIT, &amp;debug))</span><br><span class="line">					log_message(LOG_INFO,</span><br><span class="line">						<span class="string">&quot;(%s) start preempt delay (%lu.%6.6lu)&quot;</span>, vrrp-&gt;iname,</span><br><span class="line">						vrrp-&gt;preempt_delay / TIMER_HZ, vrrp-&gt;preempt_delay % TIMER_HZ);</span><br><span class="line">				vrrp-&gt;preempt_time = timer_add_long(timer_now(), vrrp-&gt;preempt_delay);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vrrp-&gt;wantstate = VRRP_STATE_BACK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 开启抢占或收到了优先级更低的vrrp报文 */</span></span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;(%s) received lower priority (%d) advert from %s - discarding&quot;</span>, vrrp-&gt;iname, hd-&gt;priority, inet_sockaddrtos(&amp;vrrp-&gt;pkt_saddr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这里设置ignore_advert为true */</span></span><br><span class="line">		ignore_advert = <span class="literal">true</span>;</span><br><span class="line">		vrrp-&gt;master_saddr = vrrp-&gt;pkt_saddr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ignore_advert) &#123;</span><br><span class="line">		<span class="comment">/* 减少ms_down_timer以尽快触发vrrp_dispatcher_read_timeout回调 */</span></span><br><span class="line">		set_time_now();</span><br><span class="line">		timersub(&amp;vrrp-&gt;sands, &amp;time_now, &amp;new_ms_down_timer);</span><br><span class="line">		vrrp-&gt;ms_down_timer = new_ms_down_timer.tv_sec &lt; <span class="number">0</span> ? <span class="number">0</span> : (<span class="type">uint32_t</span>)(new_ms_down_timer.tv_sec * TIMER_HZ + new_ms_down_timer.tv_usec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/28/jemalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">jemalloc源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-28 17:43:09" itemprop="dateCreated datePublished" datetime="2024-03-28T17:43:09+08:00">2024-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 14:44:42" itemprop="dateModified" datetime="2024-09-01T14:44:42+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jemalloc/" itemprop="url" rel="index"><span itemprop="name">jemalloc</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>version: 5.1.0</p>
<h2 id="how-to-use-it"><a href="#how-to-use-it" class="headerlink" title="how to use it"></a>how to use it</h2><p>在编译项目时链接上jemalloc库即可，gcc project.c -o project -ljemalloc `jemalloc-config –libs`，<br>之后项目中所有使用malloc或者calloc等动态内存分配的地方都会自动替换为jemalloc内的实现</p>
<h2 id="传统内存分配器的主要性能瓶颈"><a href="#传统内存分配器的主要性能瓶颈" class="headerlink" title="传统内存分配器的主要性能瓶颈"></a>传统内存分配器的主要性能瓶颈</h2><ol>
<li>竞态条件</li>
<li>内存碎片问题</li>
</ol>
<p>对于多线程环境下锁竞争的问题，jemalloc使用线程特定数据(thread specific data)来缓解，<br>并通过线程特定缓存(thread specific cache)提升性能。<br>关于内存碎片问题，jemalloc根据用户要求分配的内存空间的大小采取不同的分配方案：小内存的分配属于small class，<br>这些内存被slab按组管理，每个slab包含一个位图(bitmap)用于跟踪分配的内存情况；大内存(large class)则使用<br>extent管理内存的分配与释放。<br>实际的内存分配是通过mmap和sbrk完成的，mmap是默认优先采取的方法，在系统支持sbrk的前提下，仅当mmap分配失败时才会尝试使用sbrk分配</p>
<h2 id="malloc-function-单线程"><a href="#malloc-function-单线程" class="headerlink" title="malloc function(单线程)"></a>malloc function(单线程)</h2><p>下面是单线程场景下的jemalloc调用流程：</p>
<ol>
<li>执行jemalloc初始化，这一步在main函数执行前执行，也就是说，在执行用户的内存分配函数前，系统首先处理自动分配的内存(测试环境下为72704)，<br>并完成初始化的过程。</li>
<li>在初始化流程中，系统会完成初期的内存分配工作(主要指一些元数据的内存分配，例如b0和a0)，完成了与当前线程相关的tsd的初始化和tcache中bins的分配，并初始化一系列全局变量用于后续的内存分配</li>
<li>初始化完成，进入后续内存分配阶段，注意此时仍处于系统自动分配内存阶段，即进入main函数前，由于要求分配的内存大小为72704，属于large class，所以应当使用extent分配。我们在初始化时已经为a0分配了一个base即b0(用于为extent分配空间)，jemalloc首先尝试复用已有的extent，当前并没有这样的extent，所以其会从base中再分配一个符合当前大小的extent，之后将当前size对齐到2M（测试中大小为2097152），通过extent_alloc_core为extent分配这样的一块空间用于管理，其中extent_alloc_core会根据当前配置选择使用mmap或sbrk；若当前base的空间不足以再分配一个extent，则通过base_block_alloc分配一个base_block_t大小的内存，并从中为extent分配内存。</li>
<li>接下来系统初期malloc完成，进入main函数，程序将根据当前要求分配的大小，从tcache或arena-&gt;extents中分配内存</li>
</ol>
<h2 id="jemalloc主要数据结构及关系"><a href="#jemalloc主要数据结构及关系" class="headerlink" title="jemalloc主要数据结构及关系"></a><code>jemalloc</code>主要数据结构及关系</h2><p>arena:<br>为内存分配的核心结构，内部包含tcache的链表，根据extents的不同类型，有三种不同的extents类别分别管理，同时也<br>通过rtree管理extent的空闲表，对于小内存则由内部的bins管理分配，由base负责内部extent的内存分配，arena_decay_t结构则负责gc的管理。</p>
<p>base:<br>负责arena元数据的分配，内部有一个base_block_t类型的链表用于存储初始化阶段分配的内存，对于arena中三种extents类型，每个extents的extent内存分配都依赖base，若当前base空间不够，则会再分配一个base_block_t类型用于内存分配。</p>
<p>extents:<br>用于大内存分配和tcache初始化，有extents_dirty，extents_muzzy，extents_retained三种类型，gc会从前一种类型<br>转为后一种，内部有lru链表用于追踪heaps内的extent，bitmap用于快速定位heaps中extent的位置，delay_coalesce标记<br>当前extents是否采用延迟联合，若是则内存分配策略采用best-fit，并延迟联合过程，否则采用first-fit。</p>
<p>extent:<br>分配内存的容器，为了提高效率采用了uint64_t类型的整数e_bits，其不同的bit表示extent的状态，e_addr则是当前extent对应的<br>内存，同时也保存了内存大小</p>
<p>tsd:<br>线程本地数据，存储当前线程相关的数据</p>
<p>tcache:<br>线程本地缓存，如果当前分配的size为small class，则从tcache的bins_small或bins_large中分配</p>
<p><img src="/png/data-structure.drawio.png" alt="数据结构"></p>
<h2 id="简要函数调用关系图"><a href="#简要函数调用关系图" class="headerlink" title="简要函数调用关系图"></a>简要函数调用关系图</h2><p><img src="/./png/jemalloc-flowchart.png" alt="流程图"></p>
<h2 id="malloc过程分析："><a href="#malloc过程分析：" class="headerlink" title="malloc过程分析："></a>malloc过程分析：</h2><h3 id="je-malloc"><a href="#je-malloc" class="headerlink" title="je_malloc"></a>je_malloc</h3><p>用于<code>malloc</code>分配内存的主函数，其内部主要对<code>static_opts_t</code>和<code>dynamic_opts_t</code>两个变量进行了初始化，这些变量主要记录了当前内存分配的一些必要<br>信息和属性，真正的内存分配工作由<code>imalloc</code>完成</p>
<ul>
<li><p>关于<code>static_opts_t</code>:<br>主要定义了有关与内存分配的一些基本属性，例如在size为0时是否分配size为1的内存，出错时是否设置errno等，<br>其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_opts_s</span> &#123;</span></span><br><span class="line">	<span class="type">bool</span> may_overflow; <span class="comment">/* 分配的size是否会导致溢出 */</span></span><br><span class="line">	<span class="type">bool</span> bump_empty_alloc; <span class="comment">/* 若分配的size为0，是否将该size设置为1 */</span></span><br><span class="line">	<span class="type">bool</span> assert_nonempty_alloc; <span class="comment">/* 是否断言size != 0，即是否执行assert(size != 0) */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> null_out_result_on_error;</span><br><span class="line">	<span class="type">bool</span> set_errno_on_error;</span><br><span class="line">	<span class="type">size_t</span> min_alignment;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *oom_string;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *invalid_alignment_string;</span><br><span class="line">	<span class="type">bool</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>dynamic_opts_t</code>:<br>其内部存储着实际分配的内存和其他内存相关的属性，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamic_opts_s</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> **result; <span class="comment">/* 存储实际分配的内存 */</span></span><br><span class="line">	<span class="type">size_t</span> num_items;</span><br><span class="line">	<span class="type">size_t</span> item_size;</span><br><span class="line">	<span class="type">size_t</span> alignment;</span><br><span class="line">	<span class="type">bool</span> zero;</span><br><span class="line">	<span class="type">unsigned</span> tcache_ind;</span><br><span class="line">	<span class="type">unsigned</span> arena_ind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc的初始化过程"><a href="#malloc的初始化过程" class="headerlink" title="malloc的初始化过程"></a>malloc的初始化过程</h3><p>在使用gdb调试过程中发现，在执行测试demo前，malloc会先被自动调用一次，并完成malloc的初始化过程，在官方文档未找到<br>相关说明，关闭.&#x2F;configure 的debug模式和gcc -g选项没有影响，猜测应当是默认行为。此过程的malloc分配的大小为72704字节，属于large_class。</p>
<p>在程序第一次调用malloc时，通过对上述过程的调试发现，程序会首先检查malloc是已被成功初始化，若没有初始化，则会调用<code>malloc_init_hard</code>完成对malloc的初始化。</p>
<p>下面是<code>malloc_init_hard</code>部分代码，初始化成功后返回<code>false</code>:</p>
<p>函数内部使用了互斥锁来保证并发安全</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">malloc_init_hard</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">tsd_t</span> *tsd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 互斥锁，内部会调用pthread_mutex_trylock，获取失败时</span></span><br><span class="line"><span class="comment">	会尝试自旋一段时间，若仍未获取到则会调用pthread_mutex_lock */</span></span><br><span class="line">	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLOCK_RETURN(tsdn, ret, reentrancy)		\</span></span><br><span class="line"><span class="meta">	malloc_init_hard_cleanup(tsdn, reentrancy);	\</span></span><br><span class="line"><span class="meta">	return ret;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 判断是否应当进行hard初始化，如果已初始化或满足相关条件则解除</span></span><br><span class="line"><span class="comment">	互斥锁并退出，这里之所以反复判断初始化过程是考虑到并发情景下可能会</span></span><br><span class="line"><span class="comment">	有别的线程执行了初始化。malloc_init_hard_needed返回true就表明尚且没有</span></span><br><span class="line"><span class="comment">	别的线程完成初始化，所以只能由本线程继续初始化过程 */</span></span><br><span class="line">	<span class="keyword">if</span> (!malloc_init_hard_needed()) &#123;</span><br><span class="line">		UNLOCK_RETURN(TSDN_NULL, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* malloc_init_a0_initialized状态由malloc_init_hard_a0_locked函数设置，</span></span><br><span class="line"><span class="comment">	或被间接调用设置。malloc_init_hard_a0_locked函数内部将当前线程的id设置</span></span><br><span class="line"><span class="comment">	为锁标识malloc_initializer，这样保证了其他线程不会重复初始化malloc，所有的</span></span><br><span class="line"><span class="comment">	malloc初始化工作都将由当前线程执行。如果发生了上述的情形，则其他线程会在当前</span></span><br><span class="line"><span class="comment">	线程完成malloc初始化前一直自旋 </span></span><br><span class="line"><span class="comment">	除此之外，该函数主要完成了下列变量的初始化(以下为测试环境下的结果)：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	pagesize：4096				系统页大小，大于4096的页jemalloc暂不支持</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	mmap_flags : MAP_PRIVATE | MAP_ANON     用于mmap的标志，若os_overcommits为true，则再加上MAP_NORESERVE标志</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	os_overcommits: true			这里是判断当前操作系统的overcommit策略，true表示系统采用了0或1策略。</span></span><br><span class="line"><span class="comment">						overcommit发生在当系统申请的总内存超出linux设置的阈值时，通过</span></span><br><span class="line"><span class="comment">						读取/proc/sys/vm/overcommit_memory可获取当前系统overcommit策略。</span></span><br><span class="line"><span class="comment">						0: Heuristic overcommit.  表示根据内部算法，接受算法允许范围内的oom</span></span><br><span class="line"><span class="comment">						1: Always overcommit.	  表示总是允许申请内存</span></span><br><span class="line"><span class="comment">						2: Never overcommit.	  表示不允许申请内存</span></span><br><span class="line"><span class="comment">						内存的申请并不总是被完全使用，所以linux一般将内存的申请和分配</span></span><br><span class="line"><span class="comment">						分开来避免内存浪费，只有程序实际使用到时才会将内存进行分配。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	init_system_thp_mode: thp_mode_always	查看系统是否支持transparent huge page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	pages_can_purge_lazy_time: true		清理时是否可以lazy purge</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	extent_rtree				rtree</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	extent_mutex_pool			互斥锁池</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	dss_base				若系统支持sbrk，则通过sbrk初始化dss_base；分配器采用的默认内存分配优先级顺序是mmap-&gt;sbrk</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	ctl_initialized: false			与mallocctl相关</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	a0					即arenas[0]，单线程环境仅会使用a0进行内存分配</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (malloc_init_state != malloc_init_a0_initialized &amp;&amp;</span><br><span class="line">	    malloc_init_hard_a0_locked()) &#123;</span><br><span class="line">		UNLOCK_RETURN(TSDN_NULL, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 释放mutex锁，应当是出于减小锁粒度的考虑而没有全局加锁 */</span></span><br><span class="line">	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化tsd，内部初始化了tcache并为其bins分配内存，将在后文详细分析 */</span></span><br><span class="line">	tsd = malloc_tsd_boot0();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="b0的初始化流程"><a href="#b0的初始化流程" class="headerlink" title="b0的初始化流程"></a>b0的初始化流程</h4><p>b0是在<code>malloc_init_hard_a0_locked</code>完成初始化的，后续a0的初始化和tcache_bin_info的初始化均依赖b0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">base_t</span> *</span><br><span class="line"><span class="title function_">base_new</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">unsigned</span> ind, <span class="type">extent_hooks_t</span> *extent_hooks)</span> &#123;</span><br><span class="line">	<span class="type">pszind_t</span> pind_last = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> extent_sn_next = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 内部调用base_map分配内存，虽然这里传递的size大小是一个base_t的大小，但在调用</span></span><br><span class="line"><span class="comment">	base_map时会将其向上对齐到2M，用来减少不连续的内存，在去除头部和gap大小后，分配的剩余的</span></span><br><span class="line"><span class="comment">	内存会通过block-&gt;extent保存起来，供后续分配内存使用 */</span></span><br><span class="line">	<span class="type">base_block_t</span> *block = base_block_alloc(tsdn, <span class="literal">NULL</span>, extent_hooks, ind,</span><br><span class="line">	    &amp;pind_last, &amp;extent_sn_next, <span class="keyword">sizeof</span>(<span class="type">base_t</span>), QUANTUM);</span><br><span class="line">	<span class="keyword">if</span> (block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> gap_size;</span><br><span class="line">	<span class="type">size_t</span> base_alignment = CACHELINE;</span><br><span class="line">	<span class="type">size_t</span> base_size = ALIGNMENT_CEILING(<span class="keyword">sizeof</span>(<span class="type">base_t</span>), base_alignment);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里是从block-&gt;extent给base结构分配内存，分配完毕后更新extent，extent-&gt;e_addr为对齐后的去除base_size的大小 */</span></span><br><span class="line">	<span class="type">base_t</span> *base = (<span class="type">base_t</span> *)base_extent_bump_alloc_helper(&amp;block-&gt;extent,</span><br><span class="line">	    &amp;gap_size, base_size, base_alignment);</span><br><span class="line">	base-&gt;ind = ind;</span><br><span class="line">	atomic_store_p(&amp;base-&gt;extent_hooks, extent_hooks, ATOMIC_RELAXED);</span><br><span class="line">	<span class="keyword">if</span> (malloc_mutex_init(&amp;base-&gt;mtx, <span class="string">&quot;base&quot;</span>, WITNESS_RANK_BASE,</span><br><span class="line">	    malloc_mutex_rank_exclusive)) &#123;</span><br><span class="line">		base_unmap(tsdn, extent_hooks, ind, block, block-&gt;size);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	base-&gt;pind_last = pind_last;</span><br><span class="line">	base-&gt;extent_sn_next = extent_sn_next;</span><br><span class="line">	base-&gt;blocks = block;</span><br><span class="line">	base-&gt;auto_thp_switched = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/* 初始化base-&gt;avail，这是用来跟踪blocks中的extent heap */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">szind_t</span> i = <span class="number">0</span>; i &lt; NSIZES; i++) &#123;</span><br><span class="line">		extent_heap_new(&amp;base-&gt;avail[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 更新extent heap */</span></span><br><span class="line">	base_extent_bump_alloc_post(base, &amp;block-&gt;extent, gap_size, base,</span><br><span class="line">	    base_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="a0的初始化流程"><a href="#a0的初始化流程" class="headerlink" title="a0的初始化流程"></a>a0的初始化流程</h4><p>主要就是从base的extent heap中分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> *</span><br><span class="line"><span class="title function_">arena_new</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">unsigned</span> ind, <span class="type">extent_hooks_t</span> *extent_hooks)</span> &#123;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line">	<span class="type">base_t</span> *base;</span><br><span class="line">	<span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 取得b0 */</span></span><br><span class="line">	<span class="keyword">if</span> (ind == <span class="number">0</span>) &#123;</span><br><span class="line">		base = b0get();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		base = base_new(tsdn, ind, extent_hooks);</span><br><span class="line">		<span class="keyword">if</span> (base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 初始化arena，从base的avail数组中挑出一个extent，并为arena分配空间，和CACHELINE对齐 */</span></span><br><span class="line">	arena = (<span class="type">arena_t</span> *)base_alloc(tsdn, base, <span class="keyword">sizeof</span>(<span class="type">arena_t</span>), CACHELINE);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="malloc-tsd-boot0"><a href="#malloc-tsd-boot0" class="headerlink" title="malloc_tsd_boot0"></a>malloc_tsd_boot0</h4><p>这是初始化tsd的方法，同时也影响了arena的extent，tsd对后续的内存分配十分重要</p>
<ul>
<li>tsd: thread specific data</li>
<li>tls: thread local storage</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">malloc_tsd_boot0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">tsd_t</span> *tsd;</span><br><span class="line"></span><br><span class="line">	ncleanups = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 通过pthread_key_create创建一个tsd key，并赋值给tsd_tsd */</span>	</span><br><span class="line">	<span class="keyword">if</span> (tsd_boot0()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* tsd_fetch取得当前线程的tsd，并初始化内部的tcache等变量 */</span></span><br><span class="line">	tsd = tsd_fetch();</span><br><span class="line">	<span class="comment">/* 设置tsd的arenas_tdata_bypass为true */</span></span><br><span class="line">	*tsd_arenas_tdata_bypassp_get(tsd) = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tsd_fetch调用下面的函数：由于是第一次获取tsd，所以走的是slow path */</span></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">tsd_fetch_impl</span><span class="params">(<span class="type">bool</span> init, <span class="type">bool</span> minimal)</span> &#123;	</span><br><span class="line"></span><br><span class="line">	<span class="type">tsd_t</span> *tsd = tsd_get(init);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init &amp;&amp; tsd_get_allocates() &amp;&amp; tsd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(tsd != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tsd-&gt;state != tsd_state_nominal)) &#123;</span><br><span class="line">		<span class="comment">/* 在这里调用tsd_fetch_slow */</span></span><br><span class="line">		<span class="keyword">return</span> tsd_fetch_slow(tsd, minimal);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(tsd_fast(tsd));</span><br><span class="line">	tsd_assert_fast(tsd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">tsd_t</span> *</span><br><span class="line"><span class="title function_">tsd_fetch_slow</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">bool</span> minimal)</span> &#123;</span><br><span class="line">	assert(!tsd_fast(tsd));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据tsd的state，第一次会走下面这个分支 */</span></span><br><span class="line">	<span class="keyword">if</span> (tsd-&gt;state == tsd_state_uninitialized) &#123;</span><br><span class="line">		<span class="comment">/* minimal为false */</span></span><br><span class="line">		<span class="keyword">if</span> (!minimal) &#123;</span><br><span class="line">			tsd-&gt;state = tsd_state_nominal;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* tsd_slow_update在首次初始化时将tsd的state设置为tsd_state_nominal_slow */</span></span><br><span class="line">			tsd_slow_update(tsd);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Trigger cleanup handler registration. */</span></span><br><span class="line">			<span class="comment">/* 在内部通过pthread_setspecific设置线程私有数据为tsd_tls */</span></span><br><span class="line">			tsd_set(tsd);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 内部初始化了rtree context，用于后面初始化tcache；</span></span><br><span class="line"><span class="comment">			调用了tsd_tcache_enabled_data_init用于对tsd进一步初始化，tsd_tcache_enabled_data_init</span></span><br><span class="line"><span class="comment">			内部开启了tsd tcache，之后通过tsd_tcache_data_init初始化tcache */</span></span><br><span class="line">			tsd_data_init(tsd);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tsd-&gt;state = tsd_state_minimal_initialized;</span><br><span class="line">			tsd_set(tsd);</span><br><span class="line">			tsd_data_init_nocleanup(tsd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> tsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完成对tcache的初始化 */</span></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">tsd_tcache_data_init</span><span class="params">(<span class="type">tsd_t</span> *tsd)</span> &#123;</span><br><span class="line">	<span class="comment">/* 拿到tsd内部的tcache */</span></span><br><span class="line">	<span class="type">tcache_t</span> *tcache = tsd_tcachep_get_unsafe(tsd);</span><br><span class="line">	assert(tcache_small_bin_get(tcache, <span class="number">0</span>)-&gt;avail == <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 得到当前tcache的栈空间大小size，测试环境下为24768 */</span>	</span><br><span class="line">	<span class="type">size_t</span> size = stack_nelms * <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	<span class="comment">/* Avoid false cacheline sharing. */</span></span><br><span class="line">	<span class="comment">/* 考虑到字节对齐等因素，计算得到当前能使用的大小，测试环境下为28672 */</span></span><br><span class="line">	size = sz_sa2u(size, CACHELINE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arena_get从arenas数组得到index为0的arena，arenas是一个全局数组，在</span></span><br><span class="line"><span class="comment">	前面的malloc_init_hard_a0_locked通过memset初始化为0。此处的avail_array</span></span><br><span class="line"><span class="comment">	由a0通过arena_extent_alloc_large分配，后文会详细介绍这个函数 */</span></span><br><span class="line">	<span class="type">void</span> *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, <span class="literal">true</span>,</span><br><span class="line">	    <span class="literal">NULL</span>, <span class="literal">true</span>, arena_get(TSDN_NULL, <span class="number">0</span>, <span class="literal">true</span>));</span><br><span class="line">	<span class="keyword">if</span> (avail_array == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 根据avail_array地址分配tcache-&gt;bins_small-&gt;avail的和tcache-&gt;bins_large-&gt;avail的</span></span><br><span class="line"><span class="comment">	内存，下面的注释也说明了这里的tcache初始化已经在malloc_init()这一步完成过了，</span></span><br><span class="line"><span class="comment">	但出于一些原因仍初始化一遍 */</span></span><br><span class="line">	tcache_init(tsd, tcache, avail_array);</span><br><span class="line">	tcache-&gt;arena = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line">	<span class="keyword">if</span> (!malloc_initialized()) &#123;</span><br><span class="line">		<span class="comment">/* If in initialization, assign to a0. */</span></span><br><span class="line">		arena = arena_get(tsd_tsdn(tsd), <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">/* 将tcache和arena关联起来 */</span>		</span><br><span class="line">		tcache_arena_associate(tsd_tsdn(tsd), tcache, arena);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arena = arena_choose(tsd, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/* This may happen if thread.tcache.enabled is used. */</span></span><br><span class="line">		<span class="keyword">if</span> (tcache-&gt;arena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			tcache_arena_associate(tsd_tsdn(tsd), tcache, arena);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(arena == tcache-&gt;arena);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="arena-extent-alloc-large-分配大内存"><a href="#arena-extent-alloc-large-分配大内存" class="headerlink" title="arena_extent_alloc_large 分配大内存"></a>arena_extent_alloc_large 分配大内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">arena_extent_alloc_large</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> usize,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span> &#123;</span><br><span class="line">	<span class="type">extent_hooks_t</span> *extent_hooks = EXTENT_HOOKS_INITIALIZER;</span><br><span class="line"></span><br><span class="line">	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),</span><br><span class="line">	    WITNESS_RANK_CORE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">szind_t</span> szind = sz_size2index(usize);</span><br><span class="line">	<span class="type">size_t</span> mapped_add;</span><br><span class="line">	<span class="type">bool</span> commit = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 首先尝试从extents_dirty分配 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extents_alloc(tsdn, arena, &amp;extent_hooks,</span><br><span class="line">	    &amp;arena-&gt;extents_dirty, <span class="literal">NULL</span>, usize, sz_large_pad, alignment, <span class="literal">false</span>,</span><br><span class="line">	    szind, zero, &amp;commit);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 再尝试从extents_muzzy分配 */</span></span><br><span class="line">		extent = extents_alloc(tsdn, arena, &amp;extent_hooks,</span><br><span class="line">		    &amp;arena-&gt;extents_muzzy, <span class="literal">NULL</span>, usize, sz_large_pad, alignment,</span><br><span class="line">		    <span class="literal">false</span>, szind, zero, &amp;commit);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> size = usize + sz_large_pad;</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 最后调用extent_alloc_wrapper方法，从b0为extent_retained分配内存，并调用mmap或sbrk为extent_retained-&gt;</span></span><br><span class="line"><span class="comment">		e_addr分配内存 */</span></span><br><span class="line">		extent = extent_alloc_wrapper(tsdn, arena, &amp;extent_hooks, <span class="literal">NULL</span>,</span><br><span class="line">		    usize, sz_large_pad, alignment, <span class="literal">false</span>, szind, zero,</span><br><span class="line">		    &amp;commit);</span><br><span class="line">		<span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * extent may be NULL on OOM, but in that case</span></span><br><span class="line"><span class="comment">			 * mapped_add isn&#x27;t used below, so there&#x27;s no need to</span></span><br><span class="line"><span class="comment">			 * conditionlly set it to 0 here.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mapped_add = size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">		mapped_add = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数调用过程过于复杂，此处仅列出最后分配内存的部分和调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipallocztm -&gt; je_arena_palloc -&gt; je_large_malloc -&gt; je_large_palloc -&gt;</span><br><span class="line">je_arena_extent_alloc_wrapper -&gt; extent_alloc_retained -&gt; extent_grow_retained -&gt;</span><br><span class="line">extent_alloc_default_impl -&gt; extent_alloc_core -&gt; je_extent_alloc_mmap -&gt;</span><br><span class="line">pages_mmap -&gt; os_pages_mmap</span><br></pre></td></tr></table></figure>

<p>至此初始化基本完成，初始化完成后，调用<code>imalloc_body</code>进行实际内存分配，注意此时分配的大小仍是系统自动调用的malloc分配的大小即72704，main函数尚未开始运行。</p>
<h3 id="imalloc-body-分配内存"><a href="#imalloc-body-分配内存" class="headerlink" title="imalloc_body 分配内存"></a>imalloc_body 分配内存</h3><p>内部调用<code>imalloc_no_sample</code>进行内存分配，下面是部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">int</span></span><br><span class="line"><span class="title function_">imalloc_body</span><span class="params">(<span class="type">static_opts_t</span> *sopts, <span class="type">dynamic_opts_t</span> *dopts, <span class="type">tsd_t</span> *tsd)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *allocation = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">szind_t</span> ind = <span class="number">0</span>;    <span class="comment">/* 用于未对齐情况 */</span></span><br><span class="line">	<span class="type">size_t</span> usize = <span class="number">0</span>;   <span class="comment">/* 用于对齐情况 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reentrancy is only checked on slow path. */</span></span><br><span class="line">	<span class="type">int8_t</span> reentrancy_level;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* This is the beginning of the &quot;core&quot; algorithm. */</span></span><br><span class="line">	<span class="comment">/* 计算usize */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;alignment == <span class="number">0</span>) &#123;</span><br><span class="line">		ind = sz_size2index(size);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ind &gt;= NSIZES)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (config_stats || (config_prof &amp;&amp; opt_prof)) &#123;</span><br><span class="line">			usize = sz_index2size(ind);</span><br><span class="line">			assert(usize &gt; <span class="number">0</span> &amp;&amp; usize &lt;= LARGE_MAXCLASS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		usize = sz_sa2u(size, dopts-&gt;alignment);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(usize == <span class="number">0</span> || usize &gt; LARGE_MAXCLASS)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* If profiling is on, get our profiling context. */</span></span><br><span class="line">	<span class="keyword">if</span> (config_prof &amp;&amp; opt_prof) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 通过imalloc_no_sample得到分配的内存，后文会介绍此函数 */</span></span><br><span class="line">		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,</span><br><span class="line">		    ind);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(allocation == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> label_oom;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* Success! */</span></span><br><span class="line">	check_entry_exit_locking(tsd_tsdn(tsd));</span><br><span class="line">	*dopts-&gt;result = allocation;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="imalloc-no-sample"><a href="#imalloc-no-sample" class="headerlink" title="imalloc_no_sample"></a>imalloc_no_sample</h4><p>根据alignment和相关属性，对参数进行处理，之后调用函数进行内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">imalloc_no_sample</span><span class="params">(<span class="type">static_opts_t</span> *sopts, <span class="type">dynamic_opts_t</span> *dopts, <span class="type">tsd_t</span> *tsd,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size, <span class="type">size_t</span> usize, <span class="type">szind_t</span> ind)</span> &#123;</span><br><span class="line">	<span class="type">tcache_t</span> *tcache;</span><br><span class="line">	<span class="type">arena_t</span> *arena;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill in the tcache. */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC) &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(!sopts-&gt;slow)) &#123;</span><br><span class="line">			<span class="comment">/* Getting tcache ptr unconditionally. */</span></span><br><span class="line">			tcache = tsd_tcachep_get(tsd);</span><br><span class="line">			assert(tcache == tcache_get(tsd));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 第一次为slow path，在这里得到tcache */</span></span><br><span class="line">			tcache = tcache_get(tsd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dopts-&gt;tcache_ind == TCACHE_IND_NONE) &#123;</span><br><span class="line">		tcache = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tcache = tcaches_get(tsd, dopts-&gt;tcache_ind);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill in the arena. */</span></span><br><span class="line">	<span class="keyword">if</span> (dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 考虑到自动arena管理，将arena置空，后续从tsd获取 */</span></span><br><span class="line">		arena = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arena = arena_get(tsd_tsdn(tsd), dopts-&gt;arena_ind, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dopts-&gt;alignment != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/* 未对齐 */</span></span><br><span class="line">		<span class="keyword">return</span> ipalloct(tsd_tsdn(tsd), usize, dopts-&gt;alignment,</span><br><span class="line">		    dopts-&gt;zero, tcache, arena);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 这里分配内存 */</span></span><br><span class="line">	<span class="keyword">return</span> iallocztm(tsd_tsdn(tsd), size, ind, dopts-&gt;zero, tcache, <span class="literal">false</span>,</span><br><span class="line">	    arena, sopts-&gt;slow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 之后经过iallocztm-&gt;arena_malloc，根据当前size，决定从tcache的分配，或从arena的extents分配 */</span></span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">szind_t</span> ind, <span class="type">bool</span> zero,</span></span><br><span class="line"><span class="params">    <span class="type">tcache_t</span> *tcache, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || tcache == <span class="literal">NULL</span>);</span><br><span class="line">	assert(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tcache可用，若分配的size满足tcache要求，则从tcache的bins中获取分配的内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tcache != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(size &lt;= SMALL_MAXCLASS)) &#123;</span><br><span class="line">			<span class="comment">/* tcache分配小内存 */</span></span><br><span class="line">			<span class="keyword">return</span> tcache_alloc_small(tsdn_tsd(tsdn), arena,</span><br><span class="line">			    tcache, size, ind, zero, slow_path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (likely(size &lt;= tcache_maxclass)) &#123;</span><br><span class="line">			<span class="comment">/* tcache分配大内存 */</span></span><br><span class="line">			<span class="keyword">return</span> tcache_alloc_large(tsdn_tsd(tsdn), arena,</span><br><span class="line">			    tcache, size, ind, zero, slow_path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* (size &gt; tcache_maxclass) case falls through. */</span></span><br><span class="line">		assert(size &gt; tcache_maxclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 自动初始化的size大小为72704，大于tcache_maxclass，所以不能从tcache</span></span><br><span class="line"><span class="comment">	中分配得到内存，只能在arena中尝试分配 */</span></span><br><span class="line">	<span class="keyword">return</span> arena_malloc_hard(tsdn, arena, size, ind, zero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">szind_t</span> ind,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> zero)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || arena != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!tsdn_null(tsdn))) &#123;</span><br><span class="line">		<span class="comment">/* 前面手动将arena置空，这里根据当前tsd，从arenas数组中得到了arena */</span></span><br><span class="line">		arena = arena_choose(tsdn_tsd(tsdn), arena);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 无法从tcache分配且分配小内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(size &lt;= SMALL_MAXCLASS)) &#123;</span><br><span class="line">		<span class="keyword">return</span> arena_malloc_small(tsdn, arena, ind, zero);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配大内存 */</span></span><br><span class="line">	<span class="keyword">return</span> large_malloc(tsdn, arena, sz_index2size(ind), zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配<strong>小内存</strong>时：<br>虽然前面提起我们是属于<code>large_class</code>，但为了节省篇幅在这里介绍下分配小内存的情况</li>
</ul>
<p>首先，如果是tcache可用的情况下，会尝试从tcache的bins中分配</p>
<p>tcache分配小内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    UNUSED <span class="type">size_t</span> size, <span class="type">szind_t</span> binind, <span class="type">bool</span> zero, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">cache_bin_t</span> *bin;</span><br><span class="line">	<span class="type">bool</span> tcache_success;</span><br><span class="line">	<span class="type">size_t</span> usize <span class="title function_">JEMALLOC_CC_SILENCE_INIT</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">	assert(binind &lt; NBINS);</span><br><span class="line">	<span class="comment">/* 根据binind从tcache-&gt;bins_small数组得到bin */</span></span><br><span class="line">	bin = tcache_small_bin_get(tcache, binind);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 若当前bin中缓存的对象数量不为0，则将剩余空间分配给ret，此时ret = *(bin-&gt;avail - bin-&gt;ncached) </span></span><br><span class="line"><span class="comment">	由于一开始缓存对象为空，所以ret == NULL</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ret = cache_bin_alloc_easy(bin, &amp;tcache_success);</span><br><span class="line">	assert(tcache_success == (ret != <span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tcache_success)) &#123;</span><br><span class="line">		<span class="comment">/* 未能从tcache分配内存，即bin中缓存对象为空 */</span></span><br><span class="line">		<span class="type">bool</span> tcache_hard_success;</span><br><span class="line">		arena = arena_choose(tsd, arena);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 通过hard方法尝试分配内存 */</span></span><br><span class="line">		ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,</span><br><span class="line">		    bin, binind, &amp;tcache_hard_success);</span><br><span class="line">		<span class="keyword">if</span> (tcache_hard_success == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过<code>tcache_alloc_small_hard</code>-&gt;<code>arena_tcache_fill_small</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">cache_bin_t</span> *tbin, <span class="type">szind_t</span> binind, <span class="type">bool</span> *tcache_success)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	assert(tcache-&gt;arena != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 调用此方法用来填充tcache bin */</span></span><br><span class="line">	arena_tcache_fill_small(tsdn, arena, tcache, tbin, binind,</span><br><span class="line">	    config_prof ? tcache-&gt;prof_accumbytes : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (config_prof) &#123;</span><br><span class="line">		tcache-&gt;prof_accumbytes = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* tcache bin填充完毕，之后再次尝试从该bin中获取可用内存 */</span></span><br><span class="line">	ret = cache_bin_alloc_easy(tbin, tcache_success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充tcache bin */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_tcache_fill_small</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">cache_bin_t</span> *tbin, <span class="type">szind_t</span> binind, <span class="type">uint64_t</span> prof_accumbytes)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> i, nfill;</span><br><span class="line">	<span class="type">bin_t</span> *bin;</span><br><span class="line"></span><br><span class="line">	assert(tbin-&gt;ncached == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从arena-&gt;bins中获取bin */</span></span><br><span class="line">	bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环中依次填充bin */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, nfill = (tcache_bin_info[binind].ncached_max &gt;&gt;</span><br><span class="line">	    tcache-&gt;lg_fill_div[binind]); i &lt; nfill; i++) &#123;</span><br><span class="line">		<span class="type">extent_t</span> *slab;</span><br><span class="line">		<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 首先尝试从slab中分配 */</span></span><br><span class="line">		<span class="keyword">if</span> ((slab = bin-&gt;slabcur) != <span class="literal">NULL</span> &amp;&amp; extent_nfree_get(slab) &gt;</span><br><span class="line">		    <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* slab不为空且剩余容量大于0，可以从slab的region中分配，后文介绍 */</span></span><br><span class="line">			ptr = arena_slab_reg_alloc(slab, &amp;bin_infos[binind]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 无法从slab中分配，后文介绍 */</span></span><br><span class="line">			ptr = arena_bin_malloc_hard(tsdn, arena, bin, binind);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">/* OOM异常，将之前分配的内存移出 */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				memmove(tbin-&gt;avail - i, tbin-&gt;avail - nfill,</span><br><span class="line">				    i * <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Insert such that low regions get used first. */</span></span><br><span class="line">		*(tbin-&gt;avail - nfill + i) = ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_mutex_unlock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	tbin-&gt;ncached = i;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从slab的region中分配 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_slab_reg_alloc</span><span class="params">(<span class="type">extent_t</span> *slab, <span class="type">const</span> <span class="type">bin_info_t</span> *bin_info)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">arena_slab_data_t</span> *slab_data = extent_slab_data_get(slab);</span><br><span class="line">	<span class="type">size_t</span> regind;</span><br><span class="line"></span><br><span class="line">	assert(extent_nfree_get(slab) &gt; <span class="number">0</span>);</span><br><span class="line">	assert(!bitmap_full(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 得到region index*/</span> </span><br><span class="line">	regind = bitmap_sfu(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 从slab分配内存 */</span></span><br><span class="line">	ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)extent_addr_get(slab) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_size * regind));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 更新slab内存容量 */</span></span><br><span class="line">	extent_nfree_dec(slab);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 走到此分支说明之前的slab无可用空间或bin-&gt;slabcur == NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_bin_malloc_hard</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">bin_t</span> *bin,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind)</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">bin_info_t</span> *bin_info;</span><br><span class="line">	<span class="type">extent_t</span> *slab;</span><br><span class="line"></span><br><span class="line">	bin_info = &amp;bin_infos[binind];</span><br><span class="line">	<span class="keyword">if</span> (!arena_is_auto(arena) &amp;&amp; bin-&gt;slabcur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* TODO：若当前不是自动分配arena，一般不会出现这种情况，通常arena在0到narenas_auto都是属于自动分配，</span></span><br><span class="line"><span class="comment">		手动分配似乎需要自己申请？这里未验证 */</span></span><br><span class="line">		arena_bin_slabs_full_insert(arena, bin, bin-&gt;slabcur);</span><br><span class="line">		bin-&gt;slabcur = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 首先获取一个未满的slab */</span></span><br><span class="line">	slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind);</span><br><span class="line">	<span class="keyword">if</span> (bin-&gt;slabcur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 结合前提，说明之前的slab即bin-&gt;slabcur无可用空间，而我们在前面又重新获取了一个未满的slab */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Another thread updated slabcur while this one ran without the</span></span><br><span class="line"><span class="comment">		 * bin lock in arena_bin_nonfull_slab_get().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (extent_nfree_get(bin-&gt;slabcur) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 当前bin的slab仍有可用空间，则从bin的slab中分配，我们此时不会走到这个分支 */</span></span><br><span class="line">			<span class="type">void</span> *ret = arena_slab_reg_alloc(bin-&gt;slabcur,</span><br><span class="line">			    bin_info);</span><br><span class="line">			<span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (extent_nfree_get(slab) == bin_info-&gt;nregs) &#123;</span><br><span class="line">					<span class="comment">/* 未满且空闲区域和bin的regions数量相等，说明之前获得的未满的slab是没有被使用的</span></span><br><span class="line"><span class="comment">					状态，释放该slab */</span></span><br><span class="line">					arena_dalloc_bin_slab(tsdn, arena, slab,</span><br><span class="line">					    bin);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/* 更新bin-&gt;slabcur指针，调整bin-&gt;slabcur指向 oldest non-full slab */</span></span><br><span class="line">					arena_bin_lower_slab(tsdn, arena, slab,</span><br><span class="line">					    bin);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 走到这里说明bin-&gt;slabcur已满，将bin-&gt;slabcur插入full slab */</span></span><br><span class="line">		arena_bin_slabs_full_insert(arena, bin, bin-&gt;slabcur);</span><br><span class="line">		bin-&gt;slabcur = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* 当前没有未满的slab */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 修改bin-&gt;slabcur指向未满的slab */</span></span><br><span class="line">	bin-&gt;slabcur = slab;</span><br><span class="line"></span><br><span class="line">	assert(extent_nfree_get(bin-&gt;slabcur) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试从新的slab中分配一个region区域并返回 */</span></span><br><span class="line">	<span class="keyword">return</span> arena_slab_reg_alloc(slab, bin_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，从tcache分配小内存完成。其主要逻辑是先从tcache的bins_small中尝试获取一个slab，如果可以从该<br>slab中分配，则返回；若当前tcache没有缓存的slab，则从arena的bin中获取bin，并填充该tcache，之后再尝试<br>从tcache中获取。</p>
<p>接下来是从<strong>tcache分配大内存</strong>：</p>
<p>tcache large bins如缓存对象为空，一次仅分配一块大内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_large</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">arena_t</span> *arena, <span class="type">tcache_t</span> *tcache, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind, <span class="type">bool</span> zero, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">cache_bin_t</span> *bin;</span><br><span class="line">	<span class="type">bool</span> tcache_success;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 前半部分和从tcache 分配small bins逻辑一致 */</span></span><br><span class="line">	assert(binind &gt;= NBINS &amp;&amp;binind &lt; nhbins);</span><br><span class="line">	bin = tcache_large_bin_get(tcache, binind);</span><br><span class="line">	ret = cache_bin_alloc_easy(bin, &amp;tcache_success);</span><br><span class="line">	assert(tcache_success == (ret != <span class="literal">NULL</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tcache_success)) &#123;</span><br><span class="line">		<span class="comment">/* 分配large bins失败 */</span></span><br><span class="line">		arena = arena_choose(tsd, arena);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(arena == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 和分配small bins不同的是，分配large bins如果失败，则从arena的extent中分配，</span></span><br><span class="line"><span class="comment">		并且由于代价昂贵，并不会填充tcache large bins，实际的填充行为由gc时执行*/</span></span><br><span class="line">		ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">	tcache_event(tsd, tcache);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>若tcache不可用，且要求分配小内存时(这里的小内存比tcache的小内存要大，即小于等于SMALL_MAXCLASS时)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_small</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">szind_t</span> binind, <span class="type">bool</span> zero)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">bin_t</span> *bin;</span><br><span class="line">	<span class="type">size_t</span> usize;</span><br><span class="line">	<span class="type">extent_t</span> *slab;</span><br><span class="line"></span><br><span class="line">	assert(binind &lt; NBINS);</span><br><span class="line">	bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">	usize = sz_index2size(binind);</span><br><span class="line"></span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;bin-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> ((slab = bin-&gt;slabcur) != <span class="literal">NULL</span> &amp;&amp; extent_nfree_get(slab) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 尝试从bin的slab中分配内存 */</span></span><br><span class="line">		ret = arena_slab_reg_alloc(slab, &amp;bin_infos[binind]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 前文已分析过此方法，这里不再赘述 */</span></span><br><span class="line">		ret = arena_bin_malloc_hard(tsdn, arena, bin, binind);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>分配<strong>大内存</strong>时：<br>通过<code>arena_extent_alloc_large</code>，从三种<code>extents</code>中得到<code>extent</code>，并从中分配内存，<code>arena_extent_alloc_large</code>函数已<br>在前面分析过，这里不再提及，还是以从extents_retained得到extent为例介绍下之后的情况：</li>
</ul>
<p>已知<code>arena_extent_alloc_large</code>调用了<code>extent_alloc_wrapper</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_alloc_wrapper</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena,</span></span><br><span class="line"><span class="params">    <span class="type">extent_hooks_t</span> **r_extent_hooks, <span class="type">void</span> *new_addr, <span class="type">size_t</span> size, <span class="type">size_t</span> pad,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> slab, <span class="type">szind_t</span> szind, <span class="type">bool</span> *zero, <span class="type">bool</span> *commit)</span> &#123;</span><br><span class="line">	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),</span><br><span class="line">	    WITNESS_RANK_CORE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	extent_hooks_assure_initialized(arena, r_extent_hooks);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 一般情况下，都可以从这个函数获得extent，内部是通过mmap获取的内存 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    new_addr, size, pad, alignment, slab, szind, zero, commit);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opt_retain &amp;&amp; new_addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* mmap没能获取到内存，尝试使用sbrk获取 */</span></span><br><span class="line">		extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,</span><br><span class="line">		    new_addr, size, pad, alignment, slab, szind, zero, commit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(extent == <span class="literal">NULL</span> || extent_dumpable_get(extent));</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取extent的函数，如果extent剩余空间不足，则会尝试通过mmap再次申请内存并放入extents */</span></span><br><span class="line"><span class="type">static</span> <span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_alloc_retained</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena,</span></span><br><span class="line"><span class="params">    <span class="type">extent_hooks_t</span> **r_extent_hooks, <span class="type">void</span> *new_addr, <span class="type">size_t</span> size, <span class="type">size_t</span> pad,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> slab, <span class="type">szind_t</span> szind, <span class="type">bool</span> *zero, <span class="type">bool</span> *commit)</span> &#123;</span><br><span class="line">	assert(size != <span class="number">0</span>);</span><br><span class="line">	assert(alignment != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	malloc_mutex_lock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 首先尝试从现有的extent中分割一部分内存用于当前的内存分配，如果extent != NULL，则成功分割出了内存 */</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extent_recycle(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    &amp;arena-&gt;extents_retained, new_addr, size, pad, alignment, slab,</span><br><span class="line">	    szind, zero, commit, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (extent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		malloc_mutex_unlock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line">		<span class="keyword">if</span> (config_prof) &#123;</span><br><span class="line">			extent_gdump_add(tsdn, extent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt_retain &amp;&amp; new_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 无法复用现有extent，尝试通过mmap分配内存 */</span></span><br><span class="line">		extent = extent_grow_retained(tsdn, arena, r_extent_hooks, size,</span><br><span class="line">		    pad, alignment, slab, szind, zero, commit);</span><br><span class="line">		<span class="comment">/* extent_grow_retained() always releases extent_grow_mtx. */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		malloc_mutex_unlock(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_mutex_assert_not_owner(tsdn, &amp;arena-&gt;extent_grow_mtx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="free过程简要分析"><a href="#free过程简要分析" class="headerlink" title="free过程简要分析"></a>free过程简要分析</h2><h3 id="free-function"><a href="#free-function" class="headerlink" title="free function"></a>free function</h3><p><code>free</code>函数的释放内存逻辑仍基于分配的size，<code>arena_dalloc</code>是用于释放内存的主方法。</p>
<p>实际由于所有的内存都是通过arena的extent去管理的，所以实际的内存释放仍要依赖arena管理，无论是<br>tcache中的slab或bin还是arena中的extent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">ifree</span><span class="params">(<span class="type">tsd_t</span> *tsd, <span class="type">void</span> *ptr, <span class="type">tcache_t</span> *tcache, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="type">alloc_ctx_t</span> alloc_ctx;</span><br><span class="line">	<span class="type">rtree_ctx_t</span> *rtree_ctx = tsd_rtree_ctx(tsd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从extents_rtree查找szind和slab，并填充进alloc_ctx */</span></span><br><span class="line">	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,</span><br><span class="line">	    (<span class="type">uintptr_t</span>)ptr, <span class="literal">true</span>, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);</span><br><span class="line">	assert(alloc_ctx.szind != NSIZES);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (likely(!slow_path)) &#123;</span><br><span class="line">		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, <span class="literal">false</span>,</span><br><span class="line">		    <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, <span class="literal">false</span>,</span><br><span class="line">		    <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>idalloctm</code>-&gt;<code>arena_dalloc</code>:<br>值得注意的是，tcache的gc不一定会立刻gc，而是尝试将之前gc的对象复用，并增加一个ncached计数，<br>方便下次分配时直接取用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">void</span> *ptr, <span class="type">tcache_t</span> *tcache,</span></span><br><span class="line"><span class="params">    <span class="type">alloc_ctx_t</span> *alloc_ctx, <span class="type">bool</span> slow_path)</span> &#123;</span><br><span class="line">	assert(!tsdn_null(tsdn) || tcache == <span class="literal">NULL</span>);</span><br><span class="line">	assert(ptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcache == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/* tcache是从tsd获取的应当不会为空，这里没有验证过什么情况下tcache可能为空 */</span></span><br><span class="line">		arena_dalloc_no_tcache(tsdn, ptr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">szind_t</span> szind;</span><br><span class="line">	<span class="type">bool</span> slab;</span><br><span class="line">	<span class="type">rtree_ctx_t</span> *rtree_ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取szind和slab */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		szind = alloc_ctx-&gt;szind;</span><br><span class="line">		slab = alloc_ctx-&gt;slab;</span><br><span class="line">		assert(szind != NSIZES);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));</span><br><span class="line">		rtree_szind_slab_read(tsdn, &amp;extents_rtree, rtree_ctx,</span><br><span class="line">		    (<span class="type">uintptr_t</span>)ptr, <span class="literal">true</span>, &amp;szind, &amp;slab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(slab)) &#123;</span><br><span class="line">		<span class="comment">/* slab不为空 */</span></span><br><span class="line">		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,</span><br><span class="line">		    slow_path);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* slab为空 */</span></span><br><span class="line">		<span class="keyword">if</span> (szind &lt; nhbins) &#123;</span><br><span class="line">			<span class="comment">/* 可释放到tcache-&gt; large bins*/</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (config_prof &amp;&amp; unlikely(szind &lt; NBINS)) &#123;</span><br><span class="line">				<span class="comment">/* 开启了监测选项 */</span></span><br><span class="line">				arena_dalloc_promoted(tsdn, ptr, tcache,</span><br><span class="line">				    slow_path);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* 从tcache释放大内存 */</span></span><br><span class="line">				tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr,</span><br><span class="line">				    szind, slow_path);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 内存很大，需要通过large_dalloc进行处理 */</span></span><br><span class="line">			<span class="type">extent_t</span> *extent = iealloc(tsdn, ptr);</span><br><span class="line">			large_dalloc(tsdn, extent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后续不再针对每个情形详细分析gc，其本质大致相同：如果是通过tcache分配的内存，则将该内存归还，更新<br>ncached计数，调整其指针位置，后续从tcache请求内存时会将该内存分配出去，达到复用的效果；当tcache的bin缓存<br>达到存储上限时也会调用gc，但仍不会实际释放内存，其内存的释放依赖arena的extent。<br>arena的extent在gc时同样不会实际释放内存，并尝试将要释放的extent放入extents_dirty，若一段时间未使用则继续放入<br>extents_muzzy，最后通过arena decay释放</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>jemalloc作为内存分配器，在多方面对glibc allocator进行了优化，包括内存碎片的减少和竞态条件的优化，本文<br>详细分析了其分配内存和gc的过程，了解了buddy 算法和slab算法，加深了对于内存池、内存分配等内容的理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/01/keepalived%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">keepalived源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-01 14:29:35" itemprop="dateCreated datePublished" datetime="2023-12-01T14:29:35+08:00">2023-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 14:31:53" itemprop="dateModified" datetime="2024-09-01T14:31:53+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/keepalived/" itemprop="url" rel="index"><span itemprop="name">keepalived</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>keepalived版本：2.0.20</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在分析源码时，本文去除了一些冗余的代码和相关的调试宏，仅突出主要的代码逻辑。</p>
<h2 id="主函数分析："><a href="#主函数分析：" class="headerlink" title="主函数分析："></a>主函数分析：</h2><p>keepalived_main为keepalived的主函数，负责：</p>
<ol>
<li>部分全局变量的初始化</li>
<li>配置文件的解析和读取</li>
<li>健康检查子进程的创建</li>
</ol>
<p>下面是keepalived_main中的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建并初始化全局变量thread_master_t *master */</span></span><br><span class="line">master = thread_make_master();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号处理函数初始化 */</span></span><br><span class="line">signal_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start_keepalived开启健康检查子进程，主进程会返回 */</span></span><br><span class="line"><span class="keyword">if</span> (!start_keepalived())</span><br><span class="line">	log_message(LOG_INFO, <span class="string">&quot;Warning - keepalived has no configuration to run&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主进程开启epoll，主要负责监控子进程，一般情况下不会返回 */</span></span><br><span class="line">launch_thread_scheduler(master);</span><br></pre></td></tr></table></figure>

<h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="thread-master-t"><a href="#thread-master-t" class="headerlink" title="thread_master_t"></a>thread_master_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量master的结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_master</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 带缓存的红黑树 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	read;  <span class="comment">/* 读线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	write; <span class="comment">/* 写线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	timer; <span class="comment">/* 计时线程 */</span></span><br><span class="line">	<span class="type">rb_root_cached_t</span>	child; <span class="comment">/* 子线程 */</span></span><br><span class="line">	<span class="type">list_head_t</span>		event;     <span class="comment">/* 事件列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGNAL_THREADS</span></span><br><span class="line">	<span class="type">list_head_t</span> 		signal;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">list_head_t</span>		ready; <span class="comment">/* 就绪事件 */</span></span><br><span class="line">	<span class="type">list_head_t</span>		unuse; <span class="comment">/* 未使用事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 相关子进程 */</span></span><br><span class="line">	<span class="type">rb_root_t</span>		child_pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* epoll 相关 */</span></span><br><span class="line">	<span class="type">rb_root_t</span>		io_events;         <span class="comment">/* events集合，每次创建event都会添加到io_events内 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>	*<span class="title">epoll_events</span>;</span></span><br><span class="line">	<span class="type">thread_event_t</span>		*current_event;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		epoll_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		epoll_count;</span><br><span class="line">	<span class="type">int</span>			epoll_fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计时相关 */</span></span><br><span class="line">	<span class="type">int</span>			timer_fd;</span><br><span class="line">	<span class="type">thread_t</span>		*timer_thread;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 信号相关 */</span></span><br><span class="line">	<span class="type">int</span>			signal_fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WITH_SNMP_</span></span><br><span class="line">	<span class="comment">/* snmp related */</span></span><br><span class="line">	<span class="type">thread_t</span>		*snmp_timer_thread;</span><br><span class="line">	<span class="type">int</span>			snmp_fdsetsize;</span><br><span class="line">	fd_set			snmp_fdset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 本地数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		alloc;  <span class="comment">/* 已分配线程计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		id;</span><br><span class="line">	<span class="type">bool</span>			shutdown_timer_running;</span><br><span class="line">&#125; <span class="type">thread_master_t</span>;</span><br></pre></td></tr></table></figure>

<p>下面是master的初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_master_t</span> *</span><br><span class="line"><span class="title function_">thread_make_master</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_master_t</span> *new;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* malloc动态分配内存 */</span></span><br><span class="line">	new = (<span class="type">thread_master_t</span> *) MALLOC(<span class="keyword">sizeof</span> (<span class="type">thread_master_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个epoll fd */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_EPOLL_CREATE1</span></span><br><span class="line">	new-&gt;epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	new-&gt;epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (new-&gt;epoll_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: Error creating EPOLL instance (%m)&quot;</span>);</span><br><span class="line">		FREE(new);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化其他变量 */</span></span><br><span class="line">	new-&gt;read = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;write = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;timer = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;child = RB_ROOT_CACHED;</span><br><span class="line">	new-&gt;io_events = RB_ROOT;</span><br><span class="line">	new-&gt;child_pid = RB_ROOT;</span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;event);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGNAL_THREADS</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;signal);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;ready);</span><br><span class="line">	INIT_LIST_HEAD(&amp;new-&gt;unuse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建timerfd */</span></span><br><span class="line">	new-&gt;timer_fd = timerfd_create(CLOCK_MONOTONIC,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TFD_NONBLOCK				<span class="comment">/* Since Linux 2.6.27 */</span></span></span><br><span class="line">						        TFD_NONBLOCK | TFD_CLOEXEC</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">							<span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">										  );</span><br><span class="line">	<span class="keyword">if</span> (new-&gt;timer_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_ERR, <span class="string">&quot;scheduler: Cant create timerfd (%m)&quot;</span>);</span><br><span class="line">		FREE(new);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过signalfd初始化信号fd */</span></span><br><span class="line">	new-&gt;signal_fd = signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个计时线程（thread_t），添加到new-&gt;read内，后续便可以被epoll监听，</span></span><br><span class="line"><span class="comment">	* 并将new-&gt;timer_thread赋值为该线程</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	new-&gt;timer_thread = thread_add_read(new, thread_timerfd_handler, <span class="literal">NULL</span>, new-&gt;timer_fd, TIMER_NEVER, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化signal_thread(thread_t)全局变量，并将其添加到new-&gt;read内 */</span></span><br><span class="line">	add_signal_read_thread(new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-t"><a href="#thread-t" class="headerlink" title="thread_t"></a>thread_t</h3><p>下面是普通线程thread_t的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="type">thread_type_t</span> type;		<span class="comment">/* 线程类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_master</span> *<span class="title">master</span>;</span>	<span class="comment">/* 指向主线程的指针 */</span></span><br><span class="line">	<span class="type">int</span> (*func)(<span class="keyword">struct</span> _thread *);	<span class="comment">/* 发生对应事件时的回调函数 */</span></span><br><span class="line">	<span class="type">void</span> *arg;			<span class="comment">/* 回调函数参数 */</span></span><br><span class="line">	<span class="type">timeval_t</span> sands;		<span class="comment">/* 剩余时间沙的值 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		<span class="type">int</span> fd;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">pid_t</span> pid;</span><br><span class="line">			<span class="type">int</span> status;</span><br><span class="line">		&#125; c;</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_event</span> *<span class="title">event</span>;</span> <span class="comment">/* 对应事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">rb_node_t</span> n;</span><br><span class="line">		<span class="type">list_head_t</span> next;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">rb_node_t</span> rb_data;</span><br><span class="line">&#125; <span class="type">thread_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="checker-t"><a href="#checker-t" class="headerlink" title="checker_t"></a>checker_t</h3><p>每种健康检查对应一个checker，下面是checker_t的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">checker</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>				(*free_func) (<span class="type">void</span> *);			<span class="comment">/* free回调 */</span></span><br><span class="line">	<span class="type">void</span>				(*dump_func) (FILE *, <span class="type">void</span> *);	<span class="comment">/* dump回调 */</span></span><br><span class="line">	<span class="type">int</span>				(*launch) (<span class="keyword">struct</span> _thread *);		<span class="comment">/* 启动健康检查时的回调 */</span></span><br><span class="line">	<span class="type">bool</span>				(*compare) (<span class="type">void</span> *, <span class="type">void</span> *);	<span class="comment">/* 比较函数，用于红黑树排序 */</span></span><br><span class="line">	<span class="type">virtual_server_t</span>		*vs;			<span class="comment">/* checker线程的虚服务 */</span></span><br><span class="line">	<span class="type">real_server_t</span>			*rs;			<span class="comment">/* checker线程的实服务 */</span></span><br><span class="line">	<span class="type">void</span>				*data;</span><br><span class="line">	<span class="type">bool</span>				enabled;		<span class="comment">/* 是否开启当前健康检查 */</span></span><br><span class="line">	<span class="type">bool</span>				is_up;			<span class="comment">/* 当前健康检查是否在运行 */</span></span><br><span class="line">	<span class="type">bool</span>				has_run;		<span class="comment">/* 当前健康检查已经至少运行过一次 */</span></span><br><span class="line">	<span class="type">conn_opts_t</span>			*co;			<span class="comment">/* 连接相关参数 */</span></span><br><span class="line">	<span class="type">int</span>				alpha;			<span class="comment">/* alpha模式 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;		<span class="comment">/* 健康检查每次运行的时间间隔 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;			<span class="comment">/* 启动健康检查时的最大随机超时时间 */</span></span><br><span class="line">	<span class="type">unsigned</span>			retry;			<span class="comment">/* 健康检查失败后重试次数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;	<span class="comment">/* 健康检查失败后重试之间的间隔 */</span></span><br><span class="line">	<span class="type">unsigned</span>			retry_it;		<span class="comment">/* 连续失败次数 */</span></span><br><span class="line">	<span class="type">unsigned</span>			default_retry;		<span class="comment">/* 健康检查失败后重试次数（默认） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			default_delay_before_retry; <span class="comment">/* 健康检查失败后重试之间的间隔（默认） */</span></span><br><span class="line">&#125; <span class="type">checker_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="virtual-server-t"><a href="#virtual-server-t" class="headerlink" title="virtual_server_t"></a>virtual_server_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">virtual_server</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*vsgname;	 	<span class="comment">/* 虚服务组名 */</span></span><br><span class="line">	<span class="type">virtual_server_group_t</span>		*vsg;	<span class="comment">/* 虚服务组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>		<span class="title">addr</span>;</span>	<span class="comment">/* 虚服务地址 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			vfwmark;</span><br><span class="line">	<span class="type">real_server_t</span>			*s_svr;		<span class="comment">/* sorry server */</span></span><br><span class="line">	<span class="type">bool</span>				s_svr_duplicates_rs;</span><br><span class="line">	<span class="type">uint16_t</span>			af;</span><br><span class="line">	<span class="type">uint16_t</span>			service_type;	<span class="comment">/* 虚服务类型，如IPPROTO_TCP、IPPROTO_UDP */</span></span><br><span class="line">	<span class="type">bool</span>				ha_suspend;</span><br><span class="line">	<span class="type">int</span>				ha_suspend_addr_count;</span><br><span class="line">	<span class="type">char</span>				sched[IP_VS_SCHEDNAME_MAXLEN];</span><br><span class="line">	<span class="type">uint32_t</span>			flags;</span><br><span class="line">	<span class="type">uint32_t</span>			persistence_timeout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下方配置基本为配置文件内的可选项 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			persistence_granularity;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*virtualhost;</span><br><span class="line">	<span class="type">int</span>				weight;</span><br><span class="line">	<span class="built_in">list</span>				rs;</span><br><span class="line">	<span class="type">int</span>				alive;</span><br><span class="line">	<span class="type">bool</span>				alpha;</span><br><span class="line">	<span class="type">bool</span>				omega;</span><br><span class="line">	<span class="type">bool</span>				inhibit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			connection_to;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;</span><br><span class="line">	<span class="type">unsigned</span>			retry;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_quorum_up;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_quorum_down;</span><br><span class="line">	<span class="type">unsigned</span>			quorum;</span><br><span class="line">	<span class="type">unsigned</span>			hysteresis;</span><br><span class="line">	<span class="type">int</span>				smtp_alert;</span><br><span class="line">	<span class="type">bool</span>				quorum_state_up;</span><br><span class="line">	<span class="type">bool</span>				reloaded;</span><br><span class="line">&#125; <span class="type">virtual_server_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="real-server-t"><a href="#real-server-t" class="headerlink" title="real_server_t"></a>real_server_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">real_server</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>		<span class="title">addr</span>;</span></span><br><span class="line">	<span class="type">int</span>				weight;</span><br><span class="line">	<span class="type">int</span>				iweight;	<span class="comment">/* 初始权重 */</span></span><br><span class="line">	<span class="type">int</span>				pweight;	<span class="comment">/* reloading前的权重 */</span></span><br><span class="line">	<span class="type">unsigned</span>			forwarding_method; <span class="comment">/* NAT/TUN/DR */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下方配置基本为配置文件内的可选项 */</span></span><br><span class="line">	<span class="type">uint32_t</span>			u_threshold;</span><br><span class="line">	<span class="type">uint32_t</span>			l_threshold;</span><br><span class="line">	<span class="type">int</span>				inhibit;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_up;</span><br><span class="line">	<span class="type">notify_script_t</span>			*notify_down;</span><br><span class="line">	<span class="type">int</span>				alpha;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			connection_to;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_loop;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			warmup;</span><br><span class="line">	<span class="type">unsigned</span>			retry;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			delay_before_retry;</span><br><span class="line">	<span class="type">int</span>				smtp_alert;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>				alive;				<span class="comment">/* 实服务器是否存活 */</span></span><br><span class="line">	<span class="type">unsigned</span>			num_failed_checkers;<span class="comment">/* 失败的健康检查计数 */</span></span><br><span class="line">	<span class="type">bool</span>				<span class="built_in">set</span>;		<span class="comment">/* 是否在ipvs内被设置 */</span></span><br><span class="line">	<span class="type">bool</span>				reloaded;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>			*virtualhost;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">real_server_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="健康检查子进程调用逻辑分析"><a href="#健康检查子进程调用逻辑分析" class="headerlink" title="健康检查子进程调用逻辑分析"></a>健康检查子进程调用逻辑分析</h2><h3 id="start-check-child"><a href="#start-check-child" class="headerlink" title="start_check_child"></a>start_check_child</h3><p>下面为创建子进程的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">start_check_child</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> *syslog_ident;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;Healthcheck child process: fork error(%s)&quot;</span></span><br><span class="line">			       , strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid) &#123;</span><br><span class="line">        <span class="comment">/* 父进程部分 */</span></span><br><span class="line">		checkers_child = pid;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;Starting Healthcheck child process, pid=%d&quot;</span></span><br><span class="line">			       , pid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建子线程，添加到master-&gt;child */</span></span><br><span class="line">		thread_add_child(master, check_respawn_thread, <span class="literal">NULL</span>,</span><br><span class="line">				 pid, TIMER_NEVER);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* 子进程部分 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设定当父进程死亡时，子进程收到SIGTERM信号 */</span></span><br><span class="line">	prctl(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设定当前进程类型为PROG_TYPE_CHECKER，与之相对的父进程类型为PROG_TYPE_PARENT */</span></span><br><span class="line">	prog_type = PROG_TYPE_CHECKER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 销毁父进程创建的master */</span></span><br><span class="line">	thread_destroy_master(master);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程的master */</span></span><br><span class="line">	master = thread_make_master();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DEBUG_</span></span><br><span class="line">	<span class="comment">/* 检查子进程的信号处理函数 */</span></span><br><span class="line">	check_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 开启健康检查 */</span></span><br><span class="line">	start_check(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 启动epoll，用于监测健康检查事件，死循环，一般不会返回 */</span></span><br><span class="line">	launch_thread_scheduler(master);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 结束健康检查 */</span></span><br><span class="line">	<span class="keyword">if</span> (two_phase_terminate)</span><br><span class="line">		checker_terminate_phase2();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		stop_check(KEEPALIVED_EXIT_OK);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(KEEPALIVED_EXIT_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="start-check"><a href="#start-check" class="headerlink" title="start_check"></a>start_check</h3><p>下面是开启健康检查的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start_check</span><span class="params">(<span class="built_in">list</span> old_checkers_queue, <span class="type">data_t</span> *old_global_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化全局变量checkers_queue */</span></span><br><span class="line">	init_checkers_queue();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解析配置文件内关键字，同时将配置文件内的健康检查注册进checkers_queue内 */</span></span><br><span class="line">	init_data(conf_file, check_init_keywords);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化ipvs，加载ipvs模块 */</span></span><br><span class="line">	<span class="keyword">if</span> ((!LIST_ISEMPTY(check_data-&gt;vs) || (reload &amp;&amp; !LIST_ISEMPTY(old_check_data-&gt;vs))) &amp;&amp;</span><br><span class="line">	    ipvs_start() != IPVS_SUCCESS) &#123;</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ssl上下文初始化 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_data-&gt;ssl_required &amp;&amp; !init_ssl_ctx())</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置timer_now全局变量 */</span></span><br><span class="line">	set_time_now();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化ipvs虚服务和实服务 */</span></span><br><span class="line">	<span class="keyword">if</span> (!init_services())</span><br><span class="line">		stop_check(KEEPALIVED_EXIT_FATAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册健康检查线程 */</span></span><br><span class="line">	register_checkers_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="register-checkers-thread"><a href="#register-checkers-thread" class="headerlink" title="register_checkers_thread"></a>register_checkers_thread</h3><p>下面是注册健康检查线程的主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">register_checkers_thread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">checker_t</span> *checker;</span><br><span class="line">	element e;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> warmup;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历checkers_queue */</span></span><br><span class="line">	LIST_FOREACH(checkers_queue, checker, e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;launch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (checker-&gt;vs-&gt;ha_suspend &amp;&amp; !checker-&gt;vs-&gt;ha_suspend_addr_count)</span><br><span class="line">				checker-&gt;enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 设置一段随机超时时间，避免同时对同一实服务器开启健康检查 */</span></span><br><span class="line">			warmup = checker-&gt;warmup;</span><br><span class="line">			<span class="keyword">if</span> (warmup)</span><br><span class="line">				warmup = warmup * (<span class="type">unsigned</span>)rand() / RAND_MAX;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前健康检查添加到master线程的timer红黑树中 */</span></span><br><span class="line">			thread_add_timer(master, checker-&gt;launch, checker,</span><br><span class="line">					 BOOTSTRAP_DELAY + warmup);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="launch-thread-scheduler"><a href="#launch-thread-scheduler" class="headerlink" title="launch_thread_scheduler"></a>launch_thread_scheduler</h3><p>使用epoll开启线程调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">launch_thread_scheduler</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal_set(SIGCHLD, thread_child_handler, m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 处理事件调度 */</span></span><br><span class="line">	process_threads(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启事件调度 */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_threads</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_t</span>* thread;</span><br><span class="line">	<span class="type">list_head_t</span> *thread_list;</span><br><span class="line">	<span class="type">int</span> thread_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * thread_fetch_next_queue会阻塞直到ready列表内有就绪的事件，</span></span><br><span class="line"><span class="comment">	 * 其内部通过epoll_wait读取master线程内的read和write就绪的事件，并将其放到ready列表内，之后返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> ((thread_list = thread_fetch_next_queue(m))) &#123;</span><br><span class="line">		thread = thread_trim_head(thread_list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 对于符合条件的线程，调用其func回调 */</span></span><br><span class="line">		<span class="keyword">if</span> (!shutting_down ||</span><br><span class="line">		    (thread-&gt;type == THREAD_READY_FD &amp;&amp;</span><br><span class="line">		     (thread-&gt;u.fd == m-&gt;timer_fd || thread-&gt;u.fd == m-&gt;signal_fd)) ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD_TIMEOUT ||</span><br><span class="line">		    thread-&gt;type == THREAD_CHILD_TERMINATED ||</span><br><span class="line">		    thread-&gt;type == THREAD_TIMER_SHUTDOWN ||</span><br><span class="line">		    thread-&gt;type == THREAD_TERMINATE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (thread-&gt;func)</span><br><span class="line">				thread_call(thread);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (thread-&gt;type == THREAD_TERMINATE_START)</span><br><span class="line">				shutting_down = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 记录下当前事件，这会加速事件的初始化速度 */</span></span><br><span class="line">		m-&gt;current_event = (thread-&gt;type == THREAD_READY_READ_FD || thread-&gt;type == THREAD_READY_WRITE_FD) ? thread-&gt;event : <span class="literal">NULL</span>;</span><br><span class="line">		thread_type = thread-&gt;type;</span><br><span class="line">		thread_add_unuse(master, thread);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 关闭 */</span></span><br><span class="line">		<span class="keyword">if</span> (shutting_down &amp;&amp; !m-&gt;shutdown_timer_running &amp;&amp; !m-&gt;child.rb_root.rb_node)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 终止 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_type == THREAD_TERMINATE)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-fetch-next-queue"><a href="#thread-fetch-next-queue" class="headerlink" title="thread_fetch_next_queue"></a>thread_fetch_next_queue</h3><p>我们的所有健康检查任务和定时事件都会在这里被监听</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得下一个准备好的事件（线程） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">list_head_t</span> *</span><br><span class="line"><span class="title function_">thread_fetch_next_queue</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> last_epoll_errno = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* event列表中有就绪事件，返回event列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;event.next != &amp;m-&gt;event)</span><br><span class="line">		<span class="keyword">return</span> &amp;m-&gt;event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ready列表中有就绪时间，返回ready列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;ready.next != &amp;m-&gt;ready)</span><br><span class="line">		<span class="keyword">return</span> &amp;m-&gt;ready;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 从read、write、timer、child四个红黑树中找到最近的超时时间，</span></span><br><span class="line"><span class="comment">		通过timerfd_settime()开启定时任务计时 */</span></span><br><span class="line">		thread_set_timer(m);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 调用epoll函数（阻塞） */</span></span><br><span class="line">		ret = epoll_wait(m-&gt;epoll_fd, m-&gt;epoll_events, m-&gt;epoll_count, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* epoll_wait调用出错 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (check_EINTR(errno))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (errno != last_epoll_errno) &#123;</span><br><span class="line">				last_epoll_errno = errno;</span><br><span class="line"></span><br><span class="line">				log_message(LOG_INFO, <span class="string">&quot;scheduler: epoll_wait error: %s&quot;</span>, strerror(errno));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (last_epoll_errno == EBADF || last_epoll_errno == EFAULT || last_epoll_errno == EINVAL)</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 处理epoll事件 */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_ev</span>;</span></span><br><span class="line">			<span class="type">thread_event_t</span> *ev;</span><br><span class="line"></span><br><span class="line">			ep_ev = &amp;m-&gt;epoll_events[i];</span><br><span class="line">			ev = ep_ev-&gt;data.ptr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 对应事件出错 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; (EPOLLHUP | EPOLLERR | EPOLLRDHUP)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ev-&gt;read) &#123;</span><br><span class="line">					thread_move_ready(m, &amp;m-&gt;read, ev-&gt;read, THREAD_READ_ERROR);</span><br><span class="line">					ev-&gt;read = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ev-&gt;write) &#123;</span><br><span class="line">					thread_move_ready(m, &amp;m-&gt;write, ev-&gt;write, THREAD_WRITE_ERROR);</span><br><span class="line">					ev-&gt;write = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (__test_bit(LOG_DETAIL_BIT, &amp;debug)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLRDHUP)</span><br><span class="line">						log_message(LOG_INFO, <span class="string">&quot;Received EPOLLRDHUP for fd %d&quot;</span>, ev-&gt;fd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 读事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ev-&gt;read) &#123;</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;scheduler: No read thread bound on fd:%d (fl:0x%.4X)&quot;</span></span><br><span class="line">						      , ev-&gt;fd, ep_ev-&gt;events);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 将读事件就绪的线程放到ready列表内 */</span></span><br><span class="line">				thread_move_ready(m, &amp;m-&gt;read, ev-&gt;read, THREAD_READY_READ_FD);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 置空表示读事件已被处理 */</span></span><br><span class="line">				ev-&gt;read = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 写事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (ep_ev-&gt;events &amp; EPOLLOUT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ev-&gt;write) &#123;</span><br><span class="line">					log_message(LOG_INFO, <span class="string">&quot;scheduler: No write thread bound on fd:%d (fl:0x%.4X)&quot;</span></span><br><span class="line">						      , ev-&gt;fd, ep_ev-&gt;events);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 将写事件就绪的线程放到ready列表内 */</span></span><br><span class="line">				thread_move_ready(m, &amp;m-&gt;write, ev-&gt;write, THREAD_READY_WRITE_FD);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 置空表示写事件已被处理 */</span></span><br><span class="line">				ev-&gt;write = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新time_now全局变量 */</span></span><br><span class="line">		set_time_now();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ready列表内不为空则返回 */</span></span><br><span class="line">		<span class="keyword">if</span> (m-&gt;ready.next != &amp;m-&gt;ready)</span><br><span class="line">			<span class="keyword">return</span> &amp;m-&gt;ready;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件的触发机制和定时机制分析"><a href="#事件的触发机制和定时机制分析" class="headerlink" title="事件的触发机制和定时机制分析"></a>事件的触发机制和定时机制分析</h2><h3 id="thread-timerfd-handler"><a href="#thread-timerfd-handler" class="headerlink" title="thread_timerfd_handler"></a>thread_timerfd_handler</h3><p>注意在<code>thread_make_master</code>函数中有<br><code>new-&gt;timer_thread = thread_add_read(new, thread_timerfd_handler, NULL, new-&gt;timer_fd, TIMER_NEVER, false);</code>，<br>这会创建一个与定时任务相关的thread结构并放进master线程的read红黑树内，当超时后timerfd就会成为可读状态，进而可以通过<br>epoll监听该定时事件，并调用回调函数<code>thread_timerfd_handler</code>。</p>
<p>定时任务的超时时间一开始被设置为<code>TIMER_NEVER</code>，表示该事件永远不会被调度，即定时并不是在此时开始的，真正开始计时是<br>在上面的<code>thread_set_timer</code>函数内通过<code>timerfd_settime</code>开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">定时任务超时后的回调函数</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">thread_timerfd_handler</span><span class="params">(<span class="type">thread_ref_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_master_t</span> *m = thread-&gt;master;</span><br><span class="line">	<span class="type">uint64_t</span> expired;</span><br><span class="line">	<span class="type">ssize_t</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read返回则表明已超出设定时间 */</span></span><br><span class="line">	len = read(m-&gt;timer_fd, &amp;expired, <span class="keyword">sizeof</span>(expired));</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">		log_message(LOG_ERR, <span class="string">&quot;scheduler: Error reading on timerfd fd:%d (%m)&quot;</span>, m-&gt;timer_fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read、write、timer、child线程中，将已就绪的线程放到ready列表内，之后会被thread_fetch_next_queue取得，</span></span><br><span class="line"><span class="comment">	进而调用其各自回调 */</span></span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;read, THREAD_READ_TIMEOUT);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;write, THREAD_WRITE_TIMEOUT);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;timer, THREAD_READY);</span><br><span class="line">	thread_rb_move_ready(m, &amp;m-&gt;child, THREAD_CHILD_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前定时任务执行完毕，添加下一个定时任务 */</span></span><br><span class="line">	m-&gt;timer_thread = thread_add_read(m, thread_timerfd_handler, <span class="literal">NULL</span>, m-&gt;timer_fd, TIMER_NEVER, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-set-timer"><a href="#thread-set-timer" class="headerlink" title="thread_set_timer"></a>thread_set_timer</h3><p>只有通过该函数，定时任务才会真正的开始计时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_set_timer</span><span class="params">(<span class="type">thread_master_t</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">timeval_t</span> timer_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">its</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里是读取timer、write、read、child四个红黑树，比较其时间沙的值，</span></span><br><span class="line"><span class="comment">	将其中定时任务最近的时间赋值给timer_wait */</span></span><br><span class="line">	timerclear(&amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;timer, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;write, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;read, &amp;timer_wait);</span><br><span class="line">	thread_update_timer(&amp;m-&gt;child, &amp;timer_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timerisset(&amp;timer_wait)) &#123;</span><br><span class="line">		<span class="comment">/* 已从四个红黑树中读取到一个最近的时间 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 再次设置time_now，保证精确度 */</span></span><br><span class="line">		set_time_now();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置timer_wait = timer_wait - time_now */</span></span><br><span class="line">		timersub(&amp;timer_wait, &amp;time_now, &amp;timer_wait);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timer_wait.tv_sec &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 定时任务发生在过去，清除timer_wait */</span></span><br><span class="line">			timerclear(&amp;timer_wait);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 走到这里一般表明红黑树中没有开启定时任务的事件，将其超时时间设置为一个非常长的时间 */</span></span><br><span class="line">		timer_wait.tv_sec = LONG_MAX;</span><br><span class="line">		timer_wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	its.it_value.tv_sec = timer_wait.tv_sec;</span><br><span class="line">	<span class="keyword">if</span> (!timerisset(&amp;timer_wait)) &#123;</span><br><span class="line">		<span class="comment">/* 如果之前定时任务发生在过去，实际超时时间会被设置为0秒1纳秒，这会很快触发其回调函数 */</span></span><br><span class="line">		its.it_value.tv_nsec = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		its.it_value.tv_nsec = timer_wait.tv_usec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 不设置时间间隔 */</span></span><br><span class="line">	its.it_interval.tv_sec = its.it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 开始计时 */</span></span><br><span class="line">	timerfd_settime(m-&gt;timer_fd, <span class="number">0</span>, &amp;its, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="thread-add-timer"><a href="#thread-add-timer" class="headerlink" title="thread_add_timer"></a>thread_add_timer</h3><p>添加一个线程到master-&gt;timer内，同样的，定时任务在设置后不会立即开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_timer</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> timer)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个thread结构 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_TIMER;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER)</span><br><span class="line">		<span class="comment">/* 定时任务关闭 */</span></span><br><span class="line">		thread-&gt;sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		<span class="comment">/* 设置线程时间沙的值为time_now + timer */</span></span><br><span class="line">		thread-&gt;sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序，插入timer红黑树内 */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;timer, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-add-read"><a href="#thread-add-read" class="headerlink" title="thread_add_read"></a>thread_add_read</h3><p>添加一个线程到master-&gt;read内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_read</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> timer, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">timeval_t</span> sands;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算read线程超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER) &#123;</span><br><span class="line">		sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">		sands.tv_usec = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread_add_read_sands(m, func, arg, fd, &amp;sands, close_on_reload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建线程，添加到master-&gt;read内 */</span></span><br><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_read_sands</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">const</span> <span class="type">timeval_t</span> *sands, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_event_t</span> *event;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果先前设置了current_event，这会加速event的初始化流程 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;current_event &amp;&amp; m-&gt;current_event-&gt;fd == fd)</span><br><span class="line">		event = m-&gt;current_event;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 先前已创建了该事件，尝试从master-&gt;io_events内读取该事件，这同样会加速event初始化流程 */</span></span><br><span class="line">		event = thread_event_get(m, fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!event) &#123;</span><br><span class="line">		<span class="comment">/* 第一次触发事件，通过thread_event_new创建一个event对象，并添加到master-&gt;io_events内,这是一个较慢</span></span><br><span class="line"><span class="comment">		的流程 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(event = thread_event_new(m, fd))) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant allocate read event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__test_bit(THREAD_FL_READ_BIT, &amp;event-&gt;flags) &amp;&amp; event-&gt;read) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: There is already read event %p (read %p) registered on fd [%d]&quot;</span>, event, event-&gt;read, fd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个read线程 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_READ;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.f.fd = fd;</span><br><span class="line">	thread-&gt;u.f.close_on_reload = close_on_reload;</span><br><span class="line">	thread-&gt;event = event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置READ flag */</span></span><br><span class="line">	__set_bit(THREAD_FL_READ_BIT, &amp;event-&gt;flags);</span><br><span class="line"></span><br><span class="line">	event-&gt;read = thread;</span><br><span class="line">	<span class="keyword">if</span> (!__test_bit(THREAD_FL_EPOLL_READ_BIT, &amp;event-&gt;flags)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过epoll_ctl添加EPOLLIN事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_event_set(thread) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant register read event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			thread_add_unuse(m, thread);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_bit(THREAD_FL_EPOLL_READ_BIT, &amp;event-&gt;flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	thread-&gt;sands = *sands;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序插入master-&gt;read */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;read, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-add-write"><a href="#thread-add-write" class="headerlink" title="thread_add_write"></a>thread_add_write</h3><p>创建并添加一个线程到master-&gt;write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_ref_t</span></span><br><span class="line"><span class="title function_">thread_add_write</span><span class="params">(<span class="type">thread_master_t</span> *m, <span class="type">thread_func_t</span> func, <span class="type">void</span> *arg, <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> timer, <span class="type">bool</span> close_on_reload)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">thread_event_t</span> *event;</span><br><span class="line">	<span class="type">thread_t</span> *thread;</span><br><span class="line"></span><br><span class="line">	assert(m != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果先前设置了current_event，这会加速event的初始化流程 */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;current_event &amp;&amp; m-&gt;current_event-&gt;fd == fd)</span><br><span class="line">		event = m-&gt;current_event;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 先前已创建了该事件，尝试从master-&gt;io_events内读取该事件，这同样会加速event初始化流程 */</span></span><br><span class="line">		event = thread_event_get(m, fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!event) &#123;</span><br><span class="line">		<span class="comment">/* 第一次触发事件，通过thread_event_new创建一个event对象，并添加到master-&gt;io_events内,这是一个较慢</span></span><br><span class="line"><span class="comment">		的流程 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(event = thread_event_new(m, fd))) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant allocate write event for fd [%d](%m)&quot;</span>, fd);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__test_bit(THREAD_FL_WRITE_BIT, &amp;event-&gt;flags) &amp;&amp; event-&gt;write) &#123;</span><br><span class="line">		log_message(LOG_INFO, <span class="string">&quot;scheduler: There is already write event registered on fd [%d]&quot;</span>, fd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个write线程 */</span></span><br><span class="line">	thread = thread_new(m);</span><br><span class="line">	thread-&gt;type = THREAD_WRITE;</span><br><span class="line">	thread-&gt;master = m;</span><br><span class="line">	thread-&gt;func = func;</span><br><span class="line">	thread-&gt;arg = arg;</span><br><span class="line">	thread-&gt;u.f.fd = fd;</span><br><span class="line">	thread-&gt;u.f.close_on_reload = close_on_reload;</span><br><span class="line">	thread-&gt;event = event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置WRITE flag */</span></span><br><span class="line">	__set_bit(THREAD_FL_WRITE_BIT, &amp;event-&gt;flags);</span><br><span class="line">	event-&gt;write = thread;</span><br><span class="line">	<span class="keyword">if</span> (!__test_bit(THREAD_FL_EPOLL_WRITE_BIT, &amp;event-&gt;flags)) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 通过epoll_ctl添加EPOLLOUT事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (thread_event_set(thread) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;scheduler: Cant register write event for fd [%d](%m)&quot;</span> , fd);</span><br><span class="line">			thread_add_unuse(m, thread);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_bit(THREAD_FL_EPOLL_WRITE_BIT, &amp;event-&gt;flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (timer == TIMER_NEVER)</span><br><span class="line">		thread-&gt;sands.tv_sec = TIMER_DISABLED;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		set_time_now();</span><br><span class="line">		thread-&gt;sands = timer_add_long(time_now, timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按timeval排序插入master-&gt;write */</span></span><br><span class="line">	rb_insert_sort_cached(&amp;m-&gt;write, thread, n, thread_timer_cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与lvs的通信"><a href="#与lvs的通信" class="headerlink" title="与lvs的通信"></a>与lvs的通信</h2><h3 id="ipvs-init"><a href="#ipvs-init" class="headerlink" title="ipvs_init"></a>ipvs_init</h3><p><code>ipvs_init</code>由<code>ipvs_start</code>在健康检查子进程中被调用，其主要负责ipvs模块的加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ipvs_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	log_message(LOG_DEBUG, <span class="string">&quot;%snitializing ipvs&quot;</span>, reload ? <span class="string">&quot;Rei&quot;</span> : <span class="string">&quot;I&quot;</span>);</span><br><span class="line">	<span class="comment">/* 初始化ipvs模块 */</span></span><br><span class="line">	<span class="keyword">if</span> (ipvs_init()) &#123;</span><br><span class="line">		<span class="comment">/* ipvs模块未加载，通过modprobe加载ipvs模块，重新进行初始化 */</span></span><br><span class="line">		<span class="keyword">if</span> (keepalived_modprobe(<span class="string">&quot;ip_vs&quot;</span>) || ipvs_init()) &#123;</span><br><span class="line">			log_message(LOG_INFO, <span class="string">&quot;IPVS: Can&#x27;t initialize ipvs: %s&quot;</span>,</span><br><span class="line">			       ipvs_strerror(errno));</span><br><span class="line">			no_ipvs = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> IPVS_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IPVS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipvs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_getinfo</span> <span class="title">ipvs_info</span>;</span></span><br><span class="line"></span><br><span class="line">	ipvs_func = ipvs_init;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过socket和内核通信 */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_RAW | SOCK_CLOEXEC, IPPROTO_RAW)) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(ipvs_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 得到ipvs_info，内部包含ipvs版本号、连接表大小、虚服务数量三个信息 */</span></span><br><span class="line">	<span class="keyword">if</span> (getsockopt(sockfd, IPPROTO_IP, IP_VS_SO_GET_INFO, (<span class="type">char</span> *)&amp;ipvs_info, &amp;len)) &#123;</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="init-services"><a href="#init-services" class="headerlink" title="init_services"></a>init_services</h3><p>init_services方法用来完成lvs虚服务和实服务的添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">init_services</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	element e;</span><br><span class="line">	<span class="type">virtual_server_t</span> *vs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历vs列表，初始化每个虚服务 */</span></span><br><span class="line">	LIST_FOREACH(check_data-&gt;vs, vs, e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!init_service_vs(vs))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">init_service_vs</span><span class="params">(<span class="type">virtual_server_t</span> * vs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ISALIVE(vs) || vs-&gt;vsg) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过setsockopt(sockfd, IPPROTO_IP, IP_VS_SO_SET_ADD, (char *)svc,</span></span><br><span class="line"><span class="comment">			sizeof(struct ip_vs_service_user))，内核会调用ipvs_add_service添加一个虚服务 */</span></span><br><span class="line">		ipvs_cmd(LVS_CMD_ADD, vs, <span class="literal">NULL</span>);</span><br><span class="line">		SET_ALIVE(vs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 同样的，利用setsockopt添加实服务 */</span></span><br><span class="line">	<span class="keyword">if</span> (!init_service_rs(vs))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vs-&gt;reloaded &amp;&amp; vs-&gt;vsgname) &#123;</span><br><span class="line">		<span class="comment">/* add reloaded dests into new vsg entries */</span></span><br><span class="line">		sync_service_vsg(vs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置vs-&gt;quorum_state_up为true */</span></span><br><span class="line">	update_quorum_state(vs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加上sorry server */</span></span><br><span class="line">	<span class="keyword">if</span> (vs-&gt;s_svr &amp;&amp; vs-&gt;s_svr-&gt;inhibit &amp;&amp; !vs-&gt;s_svr-&gt;<span class="built_in">set</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vs-&gt;s_svr_duplicates_rs)</span><br><span class="line">			vs-&gt;s_svr-&gt;<span class="built_in">set</span> = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			vs-&gt;s_svr-&gt;num_failed_checkers = <span class="number">1</span>;</span><br><span class="line">			ipvs_cmd(LVS_CMD_ADD_DEST, vs, vs-&gt;s_svr);</span><br><span class="line">			vs-&gt;s_svr-&gt;num_failed_checkers = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="update-svr-checker-state"><a href="#update-svr-checker-state" class="headerlink" title="update_svr_checker_state"></a>update_svr_checker_state</h3><p>健康检查成功或失败时，会调用<code>update_svr_checker_state</code>更新checker状态，添加或删除实服务</p>
<p>在首次运行健康检查时，如果没有开启alpha模式，虚服务对应的实服务会都被添加到lvs上，若此时对应<br>的健康检查也成功，则下方会在第一个if代码块内返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">update_svr_checker_state</span><span class="params">(<span class="type">bool</span> alive, <span class="type">checker_t</span> *checker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 健康检查开启且检查成功 或 健康检查关闭且检查失败 */</span></span><br><span class="line">	<span class="keyword">if</span> (checker-&gt;is_up == alive) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!checker-&gt;has_run) &#123;</span><br><span class="line">			<span class="comment">/* 首次运行健康检查 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (checker-&gt;alpha || !alive)</span><br><span class="line">				<span class="comment">/* alpha模式开启或此次健康检查失败 */</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">/* 调用notify_up或notify_down脚本 */</span></span><br><span class="line">				do_rs_notifies(checker-&gt;vs, checker-&gt;rs, <span class="literal">false</span>);</span><br><span class="line">			checker-&gt;has_run = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 走到这里表明我们可能需要添加或删除实服务器 */</span></span><br><span class="line"></span><br><span class="line">	checker-&gt;has_run = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alive) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 此次健康检查成功，且对当前rs的健康检查失败次数小于等于1，防止重复添加rs */</span></span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;rs-&gt;num_failed_checkers &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前rs添加到lvs */</span></span><br><span class="line">			<span class="keyword">if</span> (!perform_svr_state(<span class="literal">true</span>, checker))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 健康检查失败，且当前实服务器的健康检查失败个数为0，防止重复移除rs */</span></span><br><span class="line">		<span class="keyword">if</span> (checker-&gt;rs-&gt;num_failed_checkers == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!perform_svr_state(<span class="literal">false</span>, checker))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新checker状态 */</span></span><br><span class="line">	set_checker_state(checker, alive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2023/11/15/lvs%E4%BC%9A%E8%AF%9D%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/15/lvs%E4%BC%9A%E8%AF%9D%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">lvs会话同步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-15 13:19:47" itemprop="dateCreated datePublished" datetime="2023-11-15T13:19:47+08:00">2023-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 13:39:22" itemprop="dateModified" datetime="2024-09-01T13:39:22+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内核版本：5.10</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p>
<h2 id="数据组成"><a href="#数据组成" class="headerlink" title="数据组成"></a>数据组成</h2><h3 id="开启会话同步时用户态向内核态发送的数据"><a href="#开启会话同步时用户态向内核态发送的数据" class="headerlink" title="开启会话同步时用户态向内核态发送的数据"></a>开启会话同步时用户态向内核态发送的数据</h3><p>通过setsockopt，用户发送了一个<code>ip_vs_daemon_kern</code>结构的数据，这个结构主要包括当前的主备状态、组播网卡和syncid。<br>下面是该结构的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_daemon_kern</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>			state; <span class="comment">/* 主机或备机 */</span></span><br><span class="line">	<span class="type">char</span>			mcast_ifn[IP_VS_IFNAME_MAXLEN]; <span class="comment">/* 组播接口名 */</span></span><br><span class="line">	<span class="type">int</span>			syncid; <span class="comment">/* syncid名，仅当主备机syncid相同时备机才会同步主机的连接表信息 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="主备同步时的数据组成"><a href="#主备同步时的数据组成" class="headerlink" title="主备同步时的数据组成"></a>主备同步时的数据组成</h3><p>在主备同步时，主机发送的数据主要由两部分构成，下面是主机（master）发送的buffer的组成：</p>
<p><strong>| ip_vs_sync_mesg | ip_vs_sync_conn |</strong></p>
<p>下面是这两个结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_mesg</span> &#123;</span></span><br><span class="line">	__u8			reserved;	<span class="comment">/* 原先的连接数，现在该项必须为0 */</span></span><br><span class="line">	__u8			syncid;		<span class="comment">/* syncid信息，备机根据syncid判断是否同步主机的连接表 */</span></span><br><span class="line">	__be16			size;		<span class="comment">/* 要发送的数据大小，具体包括sizeof(struct ip_vs_sync_mesg) + sizeof(struct ip_vs_sync_v4) + 其他 */</span></span><br><span class="line">	__u8			nr_conns;	<span class="comment">/* 需要同步的连接数，初始为0 */</span></span><br><span class="line">	__s8			version;	<span class="comment">/* 同步协议版本，默认为1 */</span></span><br><span class="line">	__u16			spare;		<span class="comment">/* 从代码里看spare恒为0 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ip_vs_sync_conn</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_v4</span>	<span class="title">v4</span>;</span>	<span class="comment">/* ipv4版本 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_v6</span>	<span class="title">v6</span>;</span>	<span class="comment">/* ipv6版本 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_v4</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 这里就是连接表内每条连接的信息，</span></span><br><span class="line"><span class="comment">	备机依据这些信息在本地建立和主机一样的连接表 */</span></span><br><span class="line">	__u8			type;</span><br><span class="line">	__u8			protocol;</span><br><span class="line">	__be16			ver_size;</span><br><span class="line">	__be32			flags;</span><br><span class="line">	__be16			state;</span><br><span class="line">	__be16			cport;</span><br><span class="line">	__be16			vport;</span><br><span class="line">	__be16			dport;</span><br><span class="line">	__be32			fwmark;</span><br><span class="line">	__be32			timeout;</span><br><span class="line">	__be32			caddr;</span><br><span class="line">	__be32			vaddr;</span><br><span class="line">	__be32			daddr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整体调用流程"><a href="#整体调用流程" class="headerlink" title="整体调用流程"></a>整体调用流程</h2><h3 id="开启会话同步功能后内核调用流程"><a href="#开启会话同步功能后内核调用流程" class="headerlink" title="开启会话同步功能后内核调用流程"></a>开启会话同步功能后内核调用流程</h3><ol>
<li>首先，ipvsadm或keepalived通过类似<code>setsockopt(sockfd, IPPROTO_IP, IP_VS_SO_SET_STARTDAEMON,(char *)&amp;dmk, sizeof(dmk))</code>和内核通信</li>
<li>内核在<code>nf_setsockopt</code>函数中调用<code>ops-&gt;set</code>方法，该方法被注册为<code>do_ip_vs_set_ctl</code></li>
<li>内核调用<code>do_ip_vs_set_ctl</code>方法，根据传递的optname <code>IP_VS_SO_SET_STARTDAEMON</code>进而调用<code>start_sync_thread</code>方法</li>
<li>在<code>start_sync_thread</code>方法中，内核根据主备机身份的不同设置线程启动函数为<code>sync_thread_master</code>或<code>sync_thread_backup</code>，并设置发送或接受数据的socket，最后通过<code>kthread_run</code>创建并启动线程</li>
</ol>
<h3 id="主备机同步数据时的调用流程"><a href="#主备机同步数据时的调用流程" class="headerlink" title="主备机同步数据时的调用流程"></a>主备机同步数据时的调用流程</h3><ol>
<li>主机向备机发送同步数据时，包会依次经过<code>NF_INET_LOCAL_OUT</code>上挂载的函数，对于ipvs这些函数按优先级分别为<code>ip_vs_local_reply4</code>和<code>ip_vs_local_request4</code></li>
<li>在<code>ip_vs_local_request4-&gt;ip_vs_in</code>中，会判断当前是否为开启了会话同步的主机，<code>if (ipvs-&gt;sync_state &amp; IP_VS_STATE_MASTER)</code>，如果满足条件则会通过<code>ip_vs_sync_conn</code>用于生成会话同步数据</li>
<li>仅在有流量请求到达主机时，主机才会调用<code>ip_vs_sync_conn</code>用于同步数据，<code>ip_vs_sync_conn</code>主要用于拼装主机需要向备机发送的同步数据，当流量请求较大时，同步的数据会被放到队列内，后续会调用<code>wake_up_process</code>唤醒主机同步线程用于发送队列内的同步数据</li>
<li>主机同步线程被唤醒后，<code>sync_thread_master</code>会从队列中不断取出同步数据并通过<code>ip_vs_send_sync_msg</code>向备机发送数据</li>
<li>对于备机，备机线程<code>sync_thread_backup</code>在收到主机传递的同步数据后，会经过<code>ip_vs_process_message</code>验证收到的同步数据，并在<code>ip_vs_proc_sync_conn-&gt;ip_vs_proc_conn</code>依据传递的flag、ip、端口等字段在本地更新或建立连接，同时将该连接放入本地lvs连接表内</li>
</ol>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="用户态与内核态交互部分"><a href="#用户态与内核态交互部分" class="headerlink" title="用户态与内核态交互部分"></a>用户态与内核态交互部分</h3><h4 id="do-ip-vs-set-ctl"><a href="#do-ip-vs-set-ctl" class="headerlink" title="do_ip_vs_set_ctl"></a>do_ip_vs_set_ctl</h4><p>这是ipvs和用户态应用交互的核心函数，用户态应用调用<code>setsockopt</code>后会调用这个函数，为了突出重点，这里仅保留了内核处理会话同步部分的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">do_ip_vs_set_ctl</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> cmd, <span class="type">sockptr_t</span> ptr, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> arg[MAX_SET_ARGLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span> *<span class="title">ipvs</span> =</span> net_ipvs(net);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确认用户有CAP_NET_ADMIN权限 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 基本校验 */</span></span><br><span class="line">	<span class="keyword">if</span> (cmd &lt; IP_VS_BASE_CTL || cmd &gt; IP_VS_SO_SET_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (len != set_arglen[CMDID(cmd)]) &#123;</span><br><span class="line">		IP_VS_DBG(<span class="number">1</span>, <span class="string">&quot;set_ctl: len %u != %u\n&quot;</span>,</span><br><span class="line">			  len, set_arglen[CMDID(cmd)]);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将用户态发送的数据拷贝到arg，这里的arg就是我们在用户态发送的ip_vs_daemon_kern结构 */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_sockptr(arg, ptr, len) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd == IP_VS_SO_SET_STARTDAEMON ||</span><br><span class="line">	    cmd == IP_VS_SO_SET_STOPDAEMON) &#123;</span><br><span class="line">		<span class="comment">/* 如果是要开启或关闭会话同步功能 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将arg转为ip_vs_daemon_user，该结构定义和ip_vs_daemon_kern完全一致 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_daemon_user</span> *<span class="title">dm</span> =</span> (<span class="keyword">struct</span> ip_vs_daemon_user *)arg;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cmd == IP_VS_SO_SET_STARTDAEMON) &#123;</span><br><span class="line">			<span class="comment">/* 开启会话同步 */</span></span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">ipvs_sync_daemon_cfg</span> <span class="title">cfg</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将组播的网卡、syncid等信息设置到cfg内 */</span></span><br><span class="line">			<span class="built_in">memset</span>(&amp;cfg, <span class="number">0</span>, <span class="keyword">sizeof</span>(cfg));</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">if</span> (strscpy(cfg.mcast_ifn, dm-&gt;mcast_ifn,</span><br><span class="line">				    <span class="keyword">sizeof</span>(cfg.mcast_ifn)) &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			cfg.syncid = dm-&gt;syncid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 启动线程，执行同步的相关操作 */</span></span><br><span class="line">			ret = start_sync_thread(ipvs, &amp;cfg, dm-&gt;state);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 关闭会话同步 */</span></span><br><span class="line"></span><br><span class="line">			ret = stop_sync_thread(ipvs, dm-&gt;state);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里去除了处理其他ipvs操作相关的代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="主备机同步部分"><a href="#主备机同步部分" class="headerlink" title="主备机同步部分"></a>主备机同步部分</h3><h4 id="start-sync-thread"><a href="#start-sync-thread" class="headerlink" title="start_sync_thread"></a>start_sync_thread</h4><p>在开启会话同步后，ipvs根据主备机身份的不同设置参数，通过创建新的线程处理同步数据的发送或接收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start_sync_thread</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="keyword">struct</span> ipvs_sync_daemon_cfg *c,</span></span><br><span class="line"><span class="params">		      <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_thread_data</span> *<span class="title">ti</span> =</span> <span class="literal">NULL</span>, *tinfo;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data);</span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>, count, hlen;</span><br><span class="line">	<span class="type">int</span> result = -ENOMEM;</span><br><span class="line">	u16 mtu, min_mtu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 增加模块使用计数 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ip_vs_use_count_inc())</span><br><span class="line">		<span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		rtnl_lock();</span><br><span class="line">		<span class="keyword">if</span> (mutex_trylock(&amp;ipvs-&gt;sync_mutex))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rtnl_unlock();</span><br><span class="line">		mutex_lock(&amp;ipvs-&gt;sync_mutex);</span><br><span class="line">		<span class="keyword">if</span> (rtnl_trylock())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		mutex_unlock(&amp;ipvs-&gt;sync_mutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sync_ports全局配置控制了开启的会话同步线程数，默认为1，首个线程其socket端口为8848，</span></span><br><span class="line"><span class="comment">	后面开启的线程端口以8848为基准依次+1 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ipvs-&gt;sync_state) &#123;</span><br><span class="line">		<span class="comment">/* 第一次，尚未设置sync_state */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* count决定了我们开启的用于会话同步的线程数量 */</span></span><br><span class="line">		count = clamp(sysctl_sync_ports(ipvs), <span class="number">1</span>, IPVS_SYNC_PORTS_MAX);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 掩码用于主机选取一个线程id用于发送当前的同步数据到备机 */</span></span><br><span class="line">		ipvs-&gt;threads_mask = count - <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		count = ipvs-&gt;threads_mask + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里设置协议族AF_INET，ip配置为224.0.0.81 */</span></span><br><span class="line">	<span class="keyword">if</span> (c-&gt;mcast_af == AF_UNSPEC) &#123;</span><br><span class="line">		c-&gt;mcast_af = AF_INET;</span><br><span class="line">		c-&gt;mcast_group.ip = cpu_to_be32(IP_VS_SYNC_GROUP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置多播端口为8848，ttl为1，这里的端口后续会加上线程id，如果设置</span></span><br><span class="line"><span class="comment">	仅开启一个线程用于会话同步，则id默认为0，端口为8848 */</span></span><br><span class="line">	<span class="keyword">if</span> (!c-&gt;mcast_port)</span><br><span class="line">		c-&gt;mcast_port = IP_VS_SYNC_PORT;</span><br><span class="line">	<span class="keyword">if</span> (!c-&gt;mcast_ttl)</span><br><span class="line">		c-&gt;mcast_ttl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据用户态传递的接口名获取网卡 */</span></span><br><span class="line">	dev = __dev_get_by_name(ipvs-&gt;net, c-&gt;mcast_ifn);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Unknown mcast interface: %s\n&quot;</span>, c-&gt;mcast_ifn);</span><br><span class="line">		result = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out_early;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置首部长度、mtu、min_mtu */</span></span><br><span class="line">	hlen = (AF_INET6 == c-&gt;mcast_af) ?</span><br><span class="line">	       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipv6hdr) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr) :</span><br><span class="line">	       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr);</span><br><span class="line">	mtu = (state == IP_VS_STATE_BACKUP) ?</span><br><span class="line">		  clamp(dev-&gt;mtu, <span class="number">1500U</span>, <span class="number">65535U</span>) : <span class="number">1500U</span>;</span><br><span class="line">	min_mtu = (state == IP_VS_STATE_BACKUP) ? <span class="number">1024</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置同步数据的最大长度 */</span></span><br><span class="line">	<span class="keyword">if</span> (c-&gt;sync_maxlen)</span><br><span class="line">		c-&gt;sync_maxlen = <span class="type">clamp_t</span>(<span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">					 c-&gt;sync_maxlen, min_mtu,</span><br><span class="line">					 <span class="number">65535</span> - hlen);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 第一次设置sync_maxlen */</span></span><br><span class="line">		c-&gt;sync_maxlen = mtu - hlen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (state == IP_VS_STATE_MASTER) &#123;</span><br><span class="line">		<span class="comment">/* 主机，负责发送同步数据 */</span></span><br><span class="line"></span><br><span class="line">		result = -EEXIST;</span><br><span class="line">		<span class="keyword">if</span> (ipvs-&gt;ms)</span><br><span class="line">			<span class="keyword">goto</span> out_early;</span><br><span class="line"></span><br><span class="line">		ipvs-&gt;mcfg = *c;</span><br><span class="line">		name = <span class="string">&quot;ipvs-m:%d:%d&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置线程调用函数 */</span></span><br><span class="line">		threadfn = sync_thread_master;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == IP_VS_STATE_BACKUP) &#123;</span><br><span class="line">		<span class="comment">/* 备机，负责接收同步数据 */</span></span><br><span class="line"></span><br><span class="line">		result = -EEXIST;</span><br><span class="line">		<span class="keyword">if</span> (ipvs-&gt;backup_tinfo)</span><br><span class="line">			<span class="keyword">goto</span> out_early;</span><br><span class="line"></span><br><span class="line">		ipvs-&gt;bcfg = *c;</span><br><span class="line">		name = <span class="string">&quot;ipvs-b:%d:%d&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 设置线程调用函数 */</span></span><br><span class="line">		threadfn = sync_thread_backup;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 出错 */</span></span><br><span class="line"></span><br><span class="line">		result = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_early;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (state == IP_VS_STATE_MASTER) &#123;</span><br><span class="line">		<span class="comment">/* 主机初始化同步数据，设置线程唤醒函数 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipvs_master_sync_state</span> *<span class="title">ms</span>;</span></span><br><span class="line"></span><br><span class="line">		result = -ENOMEM;</span><br><span class="line">		ipvs-&gt;ms = kcalloc(count, <span class="keyword">sizeof</span>(ipvs-&gt;ms[<span class="number">0</span>]), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!ipvs-&gt;ms)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ms = ipvs-&gt;ms;</span><br><span class="line">		<span class="keyword">for</span> (id = <span class="number">0</span>; id &lt; count; id++, ms++) &#123;</span><br><span class="line">			<span class="comment">/* 初始化每个线程的ipvs_master_sync_state */</span></span><br><span class="line">			INIT_LIST_HEAD(&amp;ms-&gt;sync_queue);</span><br><span class="line">			ms-&gt;sync_queue_len = <span class="number">0</span>;</span><br><span class="line">			ms-&gt;sync_queue_delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 初始化ms-&gt;master_wakeup_work，设置ms-&gt;master_wakeup_work-&gt;work-&gt;func = master_wakeup_work_handler，master_wakeup_work_handler会被放到system_wq内被</span></span><br><span class="line"><span class="comment">			延迟调度 */</span></span><br><span class="line">			INIT_DELAYED_WORK(&amp;ms-&gt;master_wakeup_work,</span><br><span class="line">					  master_wakeup_work_handler);</span><br><span class="line">			ms-&gt;ipvs = ipvs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result = -ENOMEM;</span><br><span class="line">	ti = kcalloc(count, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_thread_data),</span><br><span class="line">		     GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ti)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (id = <span class="number">0</span>; id &lt; count; id++) &#123;</span><br><span class="line">		<span class="comment">/* 为每个线程初始化对应的socket和相关数据，并创建线程 */</span></span><br><span class="line"></span><br><span class="line">		tinfo = &amp;ti[id];</span><br><span class="line">		tinfo-&gt;ipvs = ipvs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果是备机，为buf分配内存用于接收主机的同步数据 */</span></span><br><span class="line">		<span class="keyword">if</span> (state == IP_VS_STATE_BACKUP) &#123;</span><br><span class="line">			result = -ENOMEM;</span><br><span class="line">			tinfo-&gt;buf = kmalloc(ipvs-&gt;bcfg.sync_maxlen,</span><br><span class="line">					     GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (!tinfo-&gt;buf)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		tinfo-&gt;id = id;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 为主机或备机生成对应socket，每个线程都有一个对应的socket，其绑定的端口为8848 + id */</span></span><br><span class="line">		<span class="keyword">if</span> (state == IP_VS_STATE_MASTER)</span><br><span class="line">			result = make_send_sock(ipvs, id, dev, &amp;tinfo-&gt;sock);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			result = make_receive_sock(ipvs, id, dev, &amp;tinfo-&gt;sock);</span><br><span class="line">		<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建并启动线程 */</span></span><br><span class="line">		task = kthread_run(threadfn, tinfo, name, ipvs-&gt;gen, id);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(task)) &#123;</span><br><span class="line">			result = PTR_ERR(task);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 该task会被master_wakeup_work_handler执行 */</span></span><br><span class="line">		tinfo-&gt;task = task;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存线程数据，设置同步状态*/</span></span><br><span class="line">	<span class="keyword">if</span> (state == IP_VS_STATE_MASTER)</span><br><span class="line">		ipvs-&gt;master_tinfo = ti;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ipvs-&gt;backup_tinfo = ti;</span><br><span class="line">	spin_lock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line">	ipvs-&gt;sync_state |= state;</span><br><span class="line">	spin_unlock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ipvs-&gt;sync_mutex);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* 错误处理，关闭线程并清理数据 */</span></span><br><span class="line">	rtnl_unlock();</span><br><span class="line">	id = min(id, count - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ti) &#123;</span><br><span class="line">		<span class="keyword">for</span> (tinfo = ti + id; tinfo &gt;= ti; tinfo--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tinfo-&gt;task)</span><br><span class="line">				kthread_stop(tinfo-&gt;task);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(ipvs-&gt;sync_state &amp; IP_VS_STATE_MASTER)) &#123;</span><br><span class="line">		kfree(ipvs-&gt;ms);</span><br><span class="line">		ipvs-&gt;ms = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;ipvs-&gt;sync_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 释放socket */</span></span><br><span class="line">	<span class="keyword">if</span> (ti) &#123;</span><br><span class="line">		<span class="keyword">for</span> (tinfo = ti + id; tinfo &gt;= ti; tinfo--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tinfo-&gt;sock)</span><br><span class="line">				sock_release(tinfo-&gt;sock);</span><br><span class="line">			kfree(tinfo-&gt;buf);</span><br><span class="line">		&#125;</span><br><span class="line">		kfree(ti);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 减少模块使用计数 */</span></span><br><span class="line">	ip_vs_use_count_dec();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">out_early:</span><br><span class="line">	mutex_unlock(&amp;ipvs-&gt;sync_mutex);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	ip_vs_use_count_dec();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-vs-sync-conn"><a href="#ip-vs-sync-conn" class="headerlink" title="ip_vs_sync_conn"></a>ip_vs_sync_conn</h4><p>当有流量访问虚服务时，主机会通过ip_vs_sync_conn设置同步数据，随后会在另一个线程中将同步数据发给备机</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ip_vs_sync_conn</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="keyword">struct</span> ip_vs_conn *cp, <span class="type">int</span> pkts)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_mesg</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">ip_vs_sync_conn</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipvs_master_sync_state</span> *<span class="title">ms</span>;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	__u8 *p;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len, pe_name_len, pad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 存在疑问，什么样的包是ONE_PACKET */</span></span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;flags &amp; IP_VS_CONN_F_ONE_PACKET)</span><br><span class="line">		<span class="keyword">goto</span> control;</span><br><span class="line">sloop:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 判断当前的连接是否符合会话同步的条件，涉及到相关全局配置 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ip_vs_sync_conn_needed(ipvs, cp, pkts))</span><br><span class="line">		<span class="keyword">goto</span> control;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查参数合法性 */</span></span><br><span class="line">	pe_name_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;pe_data_len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!cp-&gt;pe_data || !cp-&gt;dest) &#123;</span><br><span class="line">			IP_VS_ERR_RL(<span class="string">&quot;SYNC, connection pe_data invalid\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pe_name_len = strnlen(cp-&gt;pe-&gt;name, IP_VS_PENAME_MAXLEN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 验证是否是主机 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(ipvs-&gt;sync_state &amp; IP_VS_STATE_MASTER)) &#123;</span><br><span class="line">		spin_unlock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 利用threads_mask选取一个线程id，下面的代码就是准备这个线程需要发送的数据 */</span></span><br><span class="line">	id = select_master_thread_id(ipvs, cp);</span><br><span class="line">	ms = &amp;ipvs-&gt;ms[id];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* struct ip_vs_sync_v4就是备机用来建立连接表项的数据，下面设置len的长度，</span></span><br><span class="line"><span class="comment">	这决定了最终发送的同步数据的大小 */</span></span><br><span class="line">	len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_v4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;flags &amp; IP_VS_CONN_F_SEQ_MASK)</span><br><span class="line">		len += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_conn_options) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;pe_data_len)</span><br><span class="line">		len += cp-&gt;pe_data_len + <span class="number">2</span>;	<span class="comment">/* + Param hdr field */</span></span><br><span class="line">	<span class="keyword">if</span> (pe_name_len)</span><br><span class="line">		len += pe_name_len + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	pad = <span class="number">0</span>;</span><br><span class="line">	buff = ms-&gt;sync_buff;</span><br><span class="line">	<span class="keyword">if</span> (buff) &#123;</span><br><span class="line">		<span class="comment">/* buff不为空，表明之前已有要发送的数据，此时还没来得及发送 */</span></span><br><span class="line"></span><br><span class="line">		m = buff-&gt;mesg;</span><br><span class="line">		pad = (<span class="number">4</span> - (<span class="type">size_t</span>) buff-&gt;head) &amp; <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (buff-&gt;head + len + pad &gt; buff-&gt;end || m-&gt;reserved) &#123;</span><br><span class="line">			<span class="comment">/* 之前的buffer剩余空间不够容纳此次的数据，于是将之前保存的buffer添加到队列内</span></span><br><span class="line"><span class="comment">			并将ms-&gt;sync_buff置空，用于保存下一次的同步数据。当一次流量过多时，</span></span><br><span class="line"><span class="comment">			队列的作用会更明显 */</span></span><br><span class="line">			sb_queue_tail(ipvs, ms);</span><br><span class="line">			ms-&gt;sync_buff = <span class="literal">NULL</span>;</span><br><span class="line">			buff = <span class="literal">NULL</span>;</span><br><span class="line">			pad = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!buff) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ms-&gt;sync_buff为空，需要新分配一个buffer用于传递这次的数据 */</span></span><br><span class="line">		buff = ip_vs_sync_buff_create(ipvs, len);</span><br><span class="line">		<span class="keyword">if</span> (!buff) &#123;</span><br><span class="line">			spin_unlock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line">			pr_err(<span class="string">&quot;ip_vs_sync_buff_create failed.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ms-&gt;sync_buff = buff;</span><br><span class="line">		m = buff-&gt;mesg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面便是填充连接相关的数据 */</span></span><br><span class="line">	p = buff-&gt;head;</span><br><span class="line">	buff-&gt;head += pad + len;</span><br><span class="line">	m-&gt;size = htons(ntohs(m-&gt;size) + pad + len);</span><br><span class="line">	<span class="keyword">while</span> (pad--)</span><br><span class="line">		*(p++) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s = (<span class="keyword">union</span> ip_vs_sync_conn *)p;</span><br><span class="line"></span><br><span class="line">	s-&gt;v4.type = (cp-&gt;af == AF_INET6 ? STYPE_F_INET6 : <span class="number">0</span>);</span><br><span class="line">	s-&gt;v4.ver_size = htons(len &amp; SVER_MASK);	<span class="comment">/* Version 0 */</span></span><br><span class="line">	s-&gt;v4.flags = htonl(cp-&gt;flags &amp; ~IP_VS_CONN_F_HASHED);</span><br><span class="line">	s-&gt;v4.state = htons(cp-&gt;state);</span><br><span class="line">	s-&gt;v4.protocol = cp-&gt;protocol;</span><br><span class="line">	s-&gt;v4.cport = cp-&gt;cport;</span><br><span class="line">	s-&gt;v4.vport = cp-&gt;vport;</span><br><span class="line">	s-&gt;v4.dport = cp-&gt;dport;</span><br><span class="line">	s-&gt;v4.fwmark = htonl(cp-&gt;fwmark);</span><br><span class="line">	s-&gt;v4.timeout = htonl(cp-&gt;timeout / HZ);</span><br><span class="line">	m-&gt;nr_conns++;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_v4);	<span class="comment">/* options ptr */</span></span><br><span class="line">		s-&gt;v4.caddr = cp-&gt;caddr.ip;</span><br><span class="line">		s-&gt;v4.vaddr = cp-&gt;vaddr.ip;</span><br><span class="line">		s-&gt;v4.daddr = cp-&gt;daddr.ip;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;flags &amp; IP_VS_CONN_F_SEQ_MASK) &#123;</span><br><span class="line">		*(p++) = IPVS_OPT_SEQ_DATA;</span><br><span class="line">		*(p++) = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_conn_options);</span><br><span class="line">		hton_seq((<span class="keyword">struct</span> ip_vs_seq *)p, &amp;cp-&gt;in_seq);</span><br><span class="line">		p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_seq);</span><br><span class="line">		hton_seq((<span class="keyword">struct</span> ip_vs_seq *)p, &amp;cp-&gt;out_seq);</span><br><span class="line">		p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_seq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;pe_data_len &amp;&amp; cp-&gt;pe_data) &#123;</span><br><span class="line">		*(p++) = IPVS_OPT_PE_DATA;</span><br><span class="line">		*(p++) = cp-&gt;pe_data_len;</span><br><span class="line">		<span class="built_in">memcpy</span>(p, cp-&gt;pe_data, cp-&gt;pe_data_len);</span><br><span class="line">		p += cp-&gt;pe_data_len;</span><br><span class="line">		<span class="keyword">if</span> (pe_name_len) &#123;</span><br><span class="line">			*(p++) = IPVS_OPT_PE_NAME;</span><br><span class="line">			*(p++) = pe_name_len;</span><br><span class="line">			<span class="built_in">memcpy</span>(p, cp-&gt;pe-&gt;name, pe_name_len);</span><br><span class="line">			p += pe_name_len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_bh(&amp;ipvs-&gt;sync_buff_lock);</span><br><span class="line"></span><br><span class="line">control:</span><br><span class="line">	<span class="comment">/* 同步当前连接的controller，一般就是指持久化模板，这里判断如果当前连接被持久化</span></span><br><span class="line"><span class="comment">	模板控制就会把持久化模板一起同步到备机 */</span></span><br><span class="line">	cp = cp-&gt;control;</span><br><span class="line">	<span class="keyword">if</span> (!cp)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cp-&gt;flags &amp; IP_VS_CONN_F_TEMPLATE)</span><br><span class="line">		pkts = atomic_add_return(<span class="number">1</span>, &amp;cp-&gt;in_pkts);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pkts = sysctl_sync_threshold(ipvs);</span><br><span class="line">	<span class="keyword">goto</span> sloop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sync-thread-master"><a href="#sync-thread-master" class="headerlink" title="sync_thread_master"></a>sync_thread_master</h4><p>主机会创建一个线程调用此方法向备机发送同步数据，同步数据通过<code>ip_vs_local_request4-&gt;ip_vs_in-&gt;ip_vs_sync_conn</code>被填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sync_thread_master</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_thread_data</span> *<span class="title">tinfo</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span> *<span class="title">ipvs</span> =</span> tinfo-&gt;ipvs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipvs_master_sync_state</span> *<span class="title">ms</span> =</span> &amp;ipvs-&gt;ms[tinfo-&gt;id];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> tinfo-&gt;sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_buff</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从ms-&gt;sync_queue队列内或ms-&gt;sync_buff内取得要发送的数据 */</span></span><br><span class="line">		sb = next_sync_buff(ipvs, ms);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(kthread_should_stop()))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (!sb) &#123;</span><br><span class="line">			<span class="comment">/* 暂时没有需要发送的数据 */</span></span><br><span class="line">			schedule_timeout(IPVS_SYNC_CHECK_PERIOD);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通过ip_vs_send_sync_msg向备机发送同步数据，如果进入这个函数可以看到其调用了ip_vs_send_async，</span></span><br><span class="line"><span class="comment">		发送的数据为sb-&gt;mesg，大小为sb-&gt;mesg-&gt;size，但实际上sb-&gt;mesg-&gt;size会大于sizeof(struct ip_vs_sync_mesg)，</span></span><br><span class="line"><span class="comment">		这是因为sb-&gt;mesg-&gt;size在ip_vs_sync_conn中被加上了sizeof(struct ip_vs_sync_v4)和一些头部数据，这就会把我们在ip_vs_sync_conn填充的ip_vs_sync_v4数据一同发送给备机 */</span></span><br><span class="line">		<span class="keyword">while</span> (ip_vs_send_sync_msg(tinfo-&gt;sock, sb-&gt;mesg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 等待直到socket可写或当前线程要终止 */</span></span><br><span class="line">			__wait_event_interruptible(*sk_sleep(sk),</span><br><span class="line">						   sock_writeable(sk) ||</span><br><span class="line">						   kthread_should_stop());</span><br><span class="line">			<span class="keyword">if</span> (unlikely(kthread_should_stop()))</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">		ip_vs_sync_buff_release(sb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">/* 线程终止，清理数据 */</span></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line">	<span class="keyword">if</span> (sb)</span><br><span class="line">		ip_vs_sync_buff_release(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((sb = sb_dequeue(ipvs, ms)))</span><br><span class="line">		ip_vs_sync_buff_release(sb);</span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	sb = get_curr_sync_buff(ipvs, ms, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sb)</span><br><span class="line">		ip_vs_sync_buff_release(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-thread-backup"><a href="#sync-thread-backup" class="headerlink" title="sync_thread_backup"></a>sync_thread_backup</h4><p>备机新建一个线程用于接收主机发来的数据，并将其送往<code>ip_vs_process_message</code>处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sync_thread_backup</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_thread_data</span> *<span class="title">tinfo</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netns_ipvs</span> *<span class="title">ipvs</span> =</span> tinfo-&gt;ipvs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> tinfo-&gt;sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udp_sock</span> *<span class="title">up</span> =</span> udp_sk(sk);</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 等待，直到有数据到来或当前线程要终止 */</span></span><br><span class="line">		wait_event_interruptible(*sk_sleep(sk),</span><br><span class="line">					 !skb_queue_empty_lockless(&amp;sk-&gt;sk_receive_queue) ||</span><br><span class="line">					 !skb_queue_empty_lockless(&amp;up-&gt;reader_queue) ||</span><br><span class="line">					 kthread_should_stop());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!skb_queue_empty_lockless(&amp;sk-&gt;sk_receive_queue) ||</span><br><span class="line">		       !skb_queue_empty_lockless(&amp;up-&gt;reader_queue)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 从主机接受数据 */</span></span><br><span class="line">			len = ip_vs_receive(tinfo-&gt;sock, tinfo-&gt;buf,</span><br><span class="line">					ipvs-&gt;bcfg.sync_maxlen);</span><br><span class="line">			<span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (len != -EAGAIN)</span><br><span class="line">					pr_err(<span class="string">&quot;receiving message error\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 处理主机发送过来的同步数据 */</span></span><br><span class="line">			ip_vs_process_message(ipvs, tinfo-&gt;buf, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ip-vs-process-message"><a href="#ip-vs-process-message" class="headerlink" title="ip_vs_process_message"></a>ip_vs_process_message</h4><p><code>ip_vs_process_message</code>负责校验从主机发送过来的数据，同时对符合条件的连接调用<code>ip_vs_proc_sync_conn</code>新建或更新连接状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ip_vs_process_message</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, __u8 *buffer,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_sync_mesg</span> *<span class="title">m2</span> =</span> (<span class="keyword">struct</span> ip_vs_sync_mesg *)buffer;</span><br><span class="line">	__u8 *p, *msg_end;</span><br><span class="line">	<span class="type">int</span> i, nr_conns;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 基本数据大小校验 */</span></span><br><span class="line">	<span class="keyword">if</span> (buflen &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_mesg_v0)) &#123;</span><br><span class="line">		IP_VS_DBG(<span class="number">2</span>, <span class="string">&quot;BACKUP, message header too short\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buflen != ntohs(m2-&gt;size)) &#123;</span><br><span class="line">		IP_VS_DBG(<span class="number">2</span>, <span class="string">&quot;BACKUP, bogus message size\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 校验syncid，仅当主机的syncid和自身的syncid相同时才同步 */</span></span><br><span class="line">	<span class="keyword">if</span> (ipvs-&gt;bcfg.syncid != <span class="number">0</span> &amp;&amp; m2-&gt;syncid != ipvs-&gt;bcfg.syncid) &#123;</span><br><span class="line">		IP_VS_DBG(<span class="number">7</span>, <span class="string">&quot;BACKUP, Ignoring syncid = %d\n&quot;</span>, m2-&gt;syncid);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 处理1版本的信息，1为默认版本 */</span></span><br><span class="line">	<span class="keyword">if</span> ((m2-&gt;version == SYNC_PROTO_VER) &amp;&amp; (m2-&gt;reserved == <span class="number">0</span>)</span><br><span class="line">	    &amp;&amp; (m2-&gt;spare == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* msg_end这里就指向struct ip_vs_sync_mesg的结尾，union ip_vs_sync_conn的开头 */</span></span><br><span class="line">		msg_end = buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_vs_sync_mesg);</span><br><span class="line">		nr_conns = m2-&gt;nr_conns;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;nr_conns; i++) &#123;</span><br><span class="line">			<span class="comment">/* 依据从主机接收到的连接数更新或新建一条连接到本地 */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> <span class="title">ip_vs_sync_conn</span> *<span class="title">s</span>;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">			<span class="type">int</span> retc;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 校验size合法性，同时将s指向当前连接 */</span></span><br><span class="line">			p = msg_end;</span><br><span class="line">			<span class="keyword">if</span> (p + <span class="keyword">sizeof</span>(s-&gt;v4) &gt; buffer+buflen) &#123;</span><br><span class="line">				IP_VS_ERR_RL(<span class="string">&quot;BACKUP, Dropping buffer, too small\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			s = (<span class="keyword">union</span> ip_vs_sync_conn *)p;</span><br><span class="line">			size = ntohs(s-&gt;v4.ver_size) &amp; SVER_MASK;</span><br><span class="line">			msg_end = p + size;</span><br><span class="line">			<span class="keyword">if</span> (msg_end  &gt; buffer+buflen) &#123;</span><br><span class="line">				IP_VS_ERR_RL(<span class="string">&quot;BACKUP, Dropping buffer, msg &gt; buffer\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ntohs(s-&gt;v4.ver_size) &gt;&gt; SVER_SHIFT) &#123;</span><br><span class="line">				IP_VS_ERR_RL(<span class="string">&quot;BACKUP, Dropping buffer, Unknown version %d\n&quot;</span>,</span><br><span class="line">					      ntohs(s-&gt;v4.ver_size) &gt;&gt; SVER_SHIFT);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 调用ip_vs_proc_sync_conn更新或新建一个连接项到连接表内 */</span></span><br><span class="line">			retc = ip_vs_proc_sync_conn(ipvs, p, msg_end);</span><br><span class="line">			<span class="keyword">if</span> (retc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				IP_VS_ERR_RL(<span class="string">&quot;BACKUP, Dropping buffer, Err: %d in decoding\n&quot;</span>,</span><br><span class="line">					     retc);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 对齐 */</span></span><br><span class="line">			msg_end = p + ((size + <span class="number">3</span>) &amp; ~<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-vs-proc-conn"><a href="#ip-vs-proc-conn" class="headerlink" title="ip_vs_proc_conn"></a>ip_vs_proc_conn</h4><p>备机通过<code>ip_vs_proc_sync_conn</code>处理option和pe，最终通过<code>ip_vs_proc_sync_conn-&gt;ip_vs_proc_conn</code>新建或更新一个连接，以实现和主机的连接表的同步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ip_vs_proc_conn</span><span class="params">(<span class="keyword">struct</span> netns_ipvs *ipvs, <span class="keyword">struct</span> ip_vs_conn_param *param,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">unsigned</span> <span class="type">int</span> state,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> protocol, <span class="type">unsigned</span> <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">union</span> nf_inet_addr *daddr, __be16 dport,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">long</span> timeout, __u32 fwmark,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> ip_vs_sync_conn_options *opt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_dest</span> *<span class="title">dest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_vs_conn</span> *<span class="title">cp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; IP_VS_CONN_F_TEMPLATE)) &#123;</span><br><span class="line">		<span class="comment">/* 需要同步的连接为一个普通连接 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 首先尝试从本地连接表内获取连接，获取的依据为cport、caddr、vport、vaddr、af、</span></span><br><span class="line"><span class="comment">		protocol、ipvs等字段的对比，而不会比较daddr和dport */</span></span><br><span class="line">		cp = ip_vs_conn_in_get(param);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cp &amp;&amp; ((cp-&gt;dport != dport) ||</span><br><span class="line">			   !ip_vs_addr_equal(cp-&gt;daf, &amp;cp-&gt;daddr, daddr))) &#123;</span><br><span class="line">			<span class="comment">/* 如果获取到了连接，但当前连接和需要同步的连接的目的ip或目的端口不同，</span></span><br><span class="line"><span class="comment">			表明需要更新这条连接的信息 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; IP_VS_CONN_F_INACTIVE)) &#123;</span><br><span class="line">				<span class="comment">/* 需要同步的连接为正常连接，为了更新本地连接，这里先让本地连接过期 */</span></span><br><span class="line"></span><br><span class="line">				ip_vs_conn_expire_now(cp);</span><br><span class="line">				__ip_vs_conn_put(cp);</span><br><span class="line">				cp = <span class="literal">NULL</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* 需要同步的连接是是一个过期连接，不需要同步，直接return */</span></span><br><span class="line">				__ip_vs_conn_put(cp);</span><br><span class="line">				kfree(param-&gt;pe_data);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 需要同步一个持久化连接，尝试从本地持久化模板获取连接 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 同样的，在获取一个持久化连接时，并不会比较其daddr和dport */</span></span><br><span class="line">		cp = ip_vs_ct_in_get(param);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cp) &#123;</span><br><span class="line">		<span class="comment">/* 成功从本地持久化模板得到连接 或 本地连接的目的端口和目的ip无需更新 */</span></span><br><span class="line">		kfree(param-&gt;pe_data);</span><br><span class="line"></span><br><span class="line">		dest = cp-&gt;dest;</span><br><span class="line">		spin_lock_bh(&amp;cp-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> ((cp-&gt;flags ^ flags) &amp; IP_VS_CONN_F_INACTIVE &amp;&amp;</span><br><span class="line">		    !(flags &amp; IP_VS_CONN_F_TEMPLATE) &amp;&amp; dest) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 更新活跃连接计数 */</span></span><br><span class="line">			<span class="keyword">if</span> (flags &amp; IP_VS_CONN_F_INACTIVE) &#123;</span><br><span class="line">				<span class="type">atomic_dec</span>(&amp;dest-&gt;activeconns);</span><br><span class="line">				<span class="type">atomic_inc</span>(&amp;dest-&gt;inactconns);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">atomic_inc</span>(&amp;dest-&gt;activeconns);</span><br><span class="line">				<span class="type">atomic_dec</span>(&amp;dest-&gt;inactconns);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新flags */</span></span><br><span class="line">		flags &amp;= IP_VS_CONN_F_BACKUP_UPD_MASK;</span><br><span class="line">		flags |= cp-&gt;flags &amp; ~IP_VS_CONN_F_BACKUP_UPD_MASK;</span><br><span class="line">		cp-&gt;flags = flags;</span><br><span class="line">		spin_unlock_bh(&amp;cp-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (!dest)</span><br><span class="line">			<span class="comment">/* 绑定实服务器 */</span></span><br><span class="line">			ip_vs_try_bind_dest(cp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 本地没有这样的连接，为了实现同步则需要新建一个连接 */</span></span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		dest = ip_vs_find_dest(ipvs, type, type, daddr, dport,</span><br><span class="line">				       param-&gt;vaddr, param-&gt;vport, protocol,</span><br><span class="line">				       fwmark, flags);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 新建连接并绑定相关参数 */</span></span><br><span class="line">		cp = ip_vs_conn_new(param, type, daddr, dport, flags, dest,</span><br><span class="line">				    fwmark);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">if</span> (!cp) &#123;</span><br><span class="line">			kfree(param-&gt;pe_data);</span><br><span class="line">			IP_VS_DBG(<span class="number">2</span>, <span class="string">&quot;BACKUP, add new conn. failed\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; IP_VS_CONN_F_TEMPLATE))</span><br><span class="line">			kfree(param-&gt;pe_data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新其他相关的连接信息 */</span></span><br><span class="line">	<span class="keyword">if</span> (opt) &#123;</span><br><span class="line">		<span class="comment">/* 更新option */</span></span><br><span class="line">		cp-&gt;in_seq = opt-&gt;in_seq;</span><br><span class="line">		cp-&gt;out_seq = opt-&gt;out_seq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;cp-&gt;in_pkts, sysctl_sync_threshold(ipvs));</span><br><span class="line">	cp-&gt;state = state;</span><br><span class="line">	cp-&gt;old_state = cp-&gt;state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">		<span class="comment">/* 更新或设置超时时间 */</span></span><br><span class="line">		<span class="keyword">if</span> (timeout &gt; MAX_SCHEDULE_TIMEOUT / HZ)</span><br><span class="line">			timeout = MAX_SCHEDULE_TIMEOUT / HZ;</span><br><span class="line">		cp-&gt;timeout = timeout*HZ;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 设置默认超时时间 */</span></span><br><span class="line">		<span class="keyword">struct</span> ip_vs_proto_data *pd;</span><br><span class="line"></span><br><span class="line">		pd = ip_vs_proto_data_get(ipvs, protocol);</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; IP_VS_CONN_F_TEMPLATE) &amp;&amp; pd &amp;&amp; pd-&gt;timeout_table)</span><br><span class="line">			cp-&gt;timeout = pd-&gt;timeout_table[state];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cp-&gt;timeout = (<span class="number">3</span>*<span class="number">60</span>*HZ);</span><br><span class="line">	&#125;</span><br><span class="line">	ip_vs_conn_put(cp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2023/11/05/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/05/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">内存对齐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-05 21:28:26" itemprop="dateCreated datePublished" datetime="2023-11-05T21:28:26+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 13:50:06" itemprop="dateModified" datetime="2024-09-01T13:50:06+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>770</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常见内存对齐公式"><a href="#常见内存对齐公式" class="headerlink" title="常见内存对齐公式"></a>常见内存对齐公式</h2><h3 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h3><p>首先是最基本的公式，对于任意<strong>整型无符号数</strong><code>operand</code>和<code>alignment</code>，将<code>operand</code>对齐到<code>alignment</code>都可以用这个公式</p>
<ul>
<li>向上对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ((operand + (alignment - <span class="number">1</span>)) / alignment) * alignment</span><br></pre></td></tr></table></figure>

<p><code>(operand + (alignment - 1)) / alignment</code>是一个向上取整的过程，保证结果最小是<code>alignment</code>（operand !&#x3D; 0）</p>
<ul>
<li>向下对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = (operand / alignment) * alignment</span><br></pre></td></tr></table></figure>



<h3 id="衍生公式"><a href="#衍生公式" class="headerlink" title="衍生公式"></a>衍生公式</h3><p>针对上面两个基本公式，对于<strong>2的幂形式</strong>的<code>alignment</code>，我们有一种新的公式可以用作对齐，考虑到在内存对齐中，一般不会存在向下对齐，故在此仅讨论向上对齐(如果要改成向下对齐，仅需将前半部分改成<code>s</code>即可)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT_CEILING(s, alignment)					\</span></span><br><span class="line"><span class="meta">	(((s) + (alignment - 1)) &amp; ((~(alignment)) + 1))</span></span><br></pre></td></tr></table></figure>

<p>当然，还有另外一种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT_CEILING(s, alignment)					\</span></span><br><span class="line"><span class="meta">	(((s) + (alignment - 1)) &amp; (~(alignment - 1))</span></span><br></pre></td></tr></table></figure>

<p><strong>Note: <u>这种形式的对齐仅能用于alignment是2的幂的形式，对于其他形式的alignment不通用</u></strong></p>
<p>接下来解释一下这两种写法：</p>
<p>首先，对于2的幂，不考虑2^0^的情况下，其二进制表示的低位表示都是0，而具体几位是零则取决于2^n^中的n。</p>
<p>例如，对于8 &#x3D; 2^3^，其二进制形式为<code>(1000)</code><del>2</del>，若想将<code>s</code>对齐到8，则就要保证其二进制表示的后三位一定要是0，其他位不变。而在二进制位运算中，若想保证最低三位为0，最简单的方法就是和8做<strong>与运算</strong>，但如果仅做与运算的话，其余高位就会丢失。所以我们必须在保证最低三位为0的情况下，高位全为1，此时才能达成目的。</p>
<p>我们注意到，如果将8减去1，二进制表示就变成了<code>(0111)</code><del>2</del>，再将其进行取反操作，高位就全变成了1，而低位都变成了0，符合我们的预期。同理，将8先取反，此时得到<code>(1111 0111)</code><del>2</del>(此处仅列出8位做演示，此时的二进制形式除低四位的高位0外其他的位都为1)，这样就完成了前面的高位全为1的保证，只需要再加上1，就能让低三位为0，高位全为1。</p>
<p>上面的两种写法，主要区别就是在后半部分。前半部分是为了保证向上对齐，后半部分则是为了保证将对齐到<code>alignment</code>。已知<code>alignment</code>是2的幂，则其取反再加1得到的就是一个二进制<strong>掩码</strong>，这个掩码将alignment低位置0，高位不变，同理，其减一再取反也可以得到同样的掩码。原数与上这样的掩码就完成了alignment的对齐操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要讨论了关于内存对齐的一些公式，包括任意的内存对齐和仅针对2次幂的对齐公式，增加了对于内存对齐和位运算的理解。后续会再完善关于内存对齐的其他内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zy-aaron.github.io/2023/08/21/rpm%E5%92%8Cdeb%E5%81%9A%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aaron Zhao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵耀的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵耀的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/21/rpm%E5%92%8Cdeb%E5%81%9A%E5%8C%85/" class="post-title-link" itemprop="url">rpm和deb做包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-21 14:26:21" itemprop="dateCreated datePublished" datetime="2023-08-21T14:26:21+08:00">2023-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-01 15:12:53" itemprop="dateModified" datetime="2024-09-01T15:12:53+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%81%9A%E5%8C%85/" itemprop="url" rel="index"><span itemprop="name">做包</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>858</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="rpm包"><a href="#rpm包" class="headerlink" title="rpm包"></a>rpm包</h2><h3 id="制作前的准备"><a href="#制作前的准备" class="headerlink" title="制作前的准备"></a>制作前的准备</h3><p>linux发行版：RedHat分支</p>
<p>安装以下工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutils patch rpmdevtools</span></span><br></pre></td></tr></table></figure>

<h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>运行<code>rpmdev-setuptree</code>，这个命令会在当前用户的<code>home</code>目录下生成制包的工作目录<code>~/rpmbuild</code>，使用<code>tree</code>命令<br>可以看到目录格式大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── BUILDROOT</span><br><span class="line">├── RPMS</span><br><span class="line">├── SOURCES</span><br><span class="line">├── SPECS</span><br><span class="line">└── SRPMS</span><br></pre></td></tr></table></figure>

<p>其中，<code>BUILDROOT</code>是构建过程中使用的临时目录，过程中生成的文件会临时存储在这里</p>
<p><code>BUILD</code>目录用于放置构建后的文件，例如从<code>SOURCES</code>目录解压后生成的文件和<code>%build</code>下生成的文件</p>
<p><code>RPMS</code>目录用于存放生成的<code>binary rpms</code>，其会根据指定架构生成不同的子目录，如<code>x86_64</code>或<code>noarch</code></p>
<p><code>SOURCES</code>目录用于存放压缩后的源代码和补丁压缩包</p>
<p><code>SPECS</code>目录用于存放<code>spec</code>配置文件</p>
<p><code>SRPMS</code>目录用于存放生成的<code>source rpms</code>文件</p>
<h4 id="SPEC文件"><a href="#SPEC文件" class="headerlink" title="SPEC文件"></a>SPEC文件</h4><p>下面是一个简单的<code>spec</code>模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Name:       Hello           #包名，应当和spec文件的文件名匹配</span><br><span class="line">Version:    1                   #版本</span><br><span class="line">Release:    1                   #发行次数</span><br><span class="line">Summary:    hello main package  </span><br><span class="line">License:    GPL</span><br><span class="line">SOURCE0:    hello.c             #源代码路径或url，一般会在SOURCES路径下寻找，这里由于存放源代码的不是压缩包，所以SOURCES目录下为空</span><br><span class="line">BUILDREQUIRES: LibHello     #rpm构建时应当具有的包</span><br><span class="line">REQUIRES:   LibHello        #rpm安装时应当具有的包</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">This is my first RPM package, which does nothing.</span><br><span class="line"></span><br><span class="line">%prep                           #可以使用%autosetup宏解压SOURCES目录下的tarball文件，一般在这里准备好构建过程要用的文件</span><br><span class="line">echo &quot;prep ...&quot;</span><br><span class="line"></span><br><span class="line">%build                          #构建过程，这里读取的是BUILD目录下的内容，执行构建命令生成二进制文件</span><br><span class="line">gcc hello.c -L. -lhello</span><br><span class="line"></span><br><span class="line">%install                        #这里描述如何安装一个文件，%&#123;buildroot&#125;是一个临时目录，在安装过程中代表根目录，</span><br><span class="line">                                后面跟着的就是系统实际目录结构，这里首先创建了这样的一个目录，之后安装的过程</span><br><span class="line">                                就是把hello二进制文件复制到/usr/local/bin目录下</span><br><span class="line">mkdir -p %&#123;buildroot&#125;/usr/local/bin/</span><br><span class="line">cp hello %&#123;buildroot&#125;/usr/local/bin/</span><br><span class="line"></span><br><span class="line">%post                           #这里是安装完后需要执行的脚本</span><br><span class="line">ln -s /usr/local/bin/hello /usr/bin/hello</span><br><span class="line"></span><br><span class="line">%postun                         #这里是卸载包完成后执行的脚本</span><br><span class="line">rm -f /usr/bin/hello</span><br><span class="line"></span><br><span class="line">%files                          #这里列出要安装到系统的文件</span><br><span class="line">/usr/local/bin/hello</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line"># let&#x27;s skip this for now</span><br></pre></td></tr></table></figure>


<p>在完成<code>spec</code>文件的编写后，可以使用<code>rpmbuild --ba packagename.spec</code>生产rpm包，–ba表示构建RPM和SRPM，-bb表示仅构建RPM，-bs表示仅构建SRPM</p>
<p>构建完成后，可以使用<code>rpm -ivh packagename.rpm</code>执行安装，或<code>rpm -e packagename</code>执行卸载</p>
<h2 id="deb包"><a href="#deb包" class="headerlink" title="deb包"></a>deb包</h2><h3 id="制作前的准备-1"><a href="#制作前的准备-1" class="headerlink" title="制作前的准备"></a>制作前的准备</h3><p>linux发行版：Debian分支</p>
<h3 id="制作过程-1"><a href="#制作过程-1" class="headerlink" title="制作过程"></a>制作过程</h3><p>以制作Hello为例，新建以下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">├── DEBIAN</span><br><span class="line">│   ├── control</span><br><span class="line">│   ├── postinst</span><br><span class="line">│   └── postrm</span><br><span class="line">└── usr</span><br><span class="line">    └── local</span><br><span class="line">        └── bin</span><br><span class="line">            └── hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，DEBIAN目录下存放deb包的制作规则以及必要的执行脚本，usr&#x2F;local&#x2F;bin&#x2F;hello目录就是最终hello文件要安装的目录</p>
<p>control文件编写模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package: Hello</span><br><span class="line">Version: 1</span><br><span class="line">Release: 1</span><br><span class="line">Maintainer: yaozhao &lt;yaozhao@abc.com&gt;</span><br><span class="line">Description: this is hello deb</span><br><span class="line">Architecture: amd64</span><br><span class="line">Priority: optional</span><br><span class="line">Pre-Depends: LibHello</span><br><span class="line">Depends: LibHello</span><br></pre></td></tr></table></figure>

<p>同样的DEBIAN目录下还可以放置<code>postinst</code>,<code>postrm</code>,<code>preinst</code>,<code>prerm</code>脚本文件，可以在deb包安装前后执行不同的shell脚本</p>
<p>准备完毕后返回Hello的父目录，执行 <code>dpkg -b Hello/ Hello.deb</code>生成Hello.deb包，<br>之后可以运行<code>dpkg -i Hello.deb</code>安装或<code>dpkg -r Hello</code>卸载</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Aaron Zhao</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">21k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:15</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
